#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Chapter::Closed:: *)
(*Preliminaries*)


(* ::Input::Initialization:: *)
inputFilePath = $InputFileName /. "" :> NotebookFileName[];
inputFileDir = DirectoryName @ inputFilePath;
pacletDir = DirectoryName[inputFileDir,2];
testsDir = FileNameJoin[{pacletDir,"Tests"}];
PacletDirectoryLoad[pacletDir];
$ContextPath=initialContextPath = Cases[$ContextPath,Except["PacletizedResourceFunctions`"]];


(* ::Input::Initialization:: *)
confirm=False;(*True pauses after every test to manually accept/reject test, False accepts all tests*)


(* ::Section:: *)
(*helper functions*)


(* ::Subsection::Closed:: *)
(*makeDefinitions*)


(* ::Input::Initialization:: *)
makeDefinitions[name_]:=(
(*ClearAll[testFileName,testFilePath,testContext,context];*)
testFileName = Last@StringSplit[name,"`"]<>".wlt";
testFilePath = FileNameJoin[{testsDir,testFileName}];
If[FileNames[testFilePath]==={},Nothing,DeleteFile[testFilePath]];testContext = "FernandoDuarte`LongRunRisk`Tests`"<>name;context = "FernandoDuarte`LongRunRisk`"<>name;
);


(* ::Subsection::Closed:: *)
(*addBeginEnd*)


(* ::Input::Initialization:: *)
(*add Begin["Context`"] and End[] to wlt file*)
addBeginEnd[testFilePath_,testContext_]:=With[
{
numLines=countLines[testFilePath]
},
replaceNthRecord[testFilePath,1,"Begin[\"" <> testContext <> "\"]"];
CopyFile[testFilePath<>"temp",testFilePath,OverwriteTarget->True];
DeleteFile[testFilePath<>"temp"];

replaceNthRecord[testFilePath,numLines-2, "End[]"];
CopyFile[testFilePath<>"temp",testFilePath,OverwriteTarget->True];
DeleteFile[testFilePath<>"temp"];
]


(* ::Subsubsection::Initialization::Closed:: *)
(*(*(*replaceNthRecord*)*)*)


(* ::Input::Initialization:: *)
replaceNthRecord[file_String, n_Integer, replaceWith_] :=
    Module[
{
readStream = OpenRead[file], 
writeStream = OpenWrite[file <> "temp"],
temp
},
Do[
WriteLine[writeStream, ReadLine[readStream]],
{n - 1}
];
WriteLine[writeStream, ReadLine[readStream] <> " \r\n" <> replaceWith];
While[
temp =!= EndOfFile,
temp = ReadLine[readStream];
If[
UnsameQ[temp, EndOfFile],
WriteLine[writeStream, temp]
];
];
Close /@ {readStream, writeStream}
]


(* ::Subsubsection::Initialization::Closed:: *)
(*(*(*countLines*)*)*)


(* ::Input::Initialization:: *)
countLines[file_String] :=
    Module[
{
readStream = OpenRead[file],
n = 1,
temp
},
While[
temp =!= EndOfFile,
temp = ReadLine[readStream];
n = n + 1;
];
Close /@ {readStream};
n
]


(* ::Subsection::Closed:: *)
(*runTests*)


(* ::Input::Initialization:: *)
runTests[testFilePath_]:=Module[
{
localTestReport= TestReport[testFilePath],
localResults,
actual,
expected,
outputTrueQ
},
localResults=localTestReport["Results"];
actual= Table[Flatten@{(ReleaseHold@(localResults[[jj,1]][["ActualOutput"]]))},{jj,1,Length[localResults]}];
expected= Table[Flatten@{(ReleaseHold@(localResults[[jj,1]][["ExpectedOutput"]]))},{jj,1,Length[localResults]}];
outputTrueQ= And@@{And@@Flatten@actual,And@@Flatten@expected};

{localTestReport,actual,expected,outputTrueQ}
]


(* ::Subsubsection::Initialization::Closed:: *)
(*(*(*tableActualVsExpeected*)*)*)


(* ::Input::Initialization:: *)
tableActualVsExpeected[testName_String,numCol_:5] := With[
    {
        actual = tr[testName]["ActualOutput"],
        expected = tr[testName]["ExpectedOutput"]
    },
    Module[
        {
            numEntries = Dimensions[actual][[1]] ,
            numRows
        },
        numRows = Floor[numEntries / numCol] + 1;
        TableForm[
            ArrayReshape[
                {
                    MapThread[
                        TableForm[
                            {#1,#2}
                        ]&
                        ,
                        {actual,expected}
                    ]
                }\[Transpose],
                {numRows , numCol},
                "--"
            ],
            TableDepth -> 1
        ]
    ]
]


(* ::Subsection::Closed:: *)
(*cleanUp*)


(* ::Input::Initialization:: *)
cleanUp[]:=With[
{
cp=Flatten@DeleteCases[StringCases[$ContextPath,"FernandoDuarte"~~__],{}],
pp=Flatten@DeleteCases[StringCases[$Packages,"FernandoDuarte"~~__],{}]
},
With[
{
nn=Join[Flatten@(Names[#<>"*"]&/@pp),Flatten@(Names[#<>"Private`"<>"*"]&/@pp)]
},
With[
{
nn$=Complement[nn,Flatten[StringCases[nn,__~~"$"]]]
},
Unprotect[Evaluate@nn$];
Remove[Evaluate@nn$];
$ContextPath=DeleteElements[$ContextPath,cp];
Unprotect[$Packages];
$Packages=DeleteElements[$Packages,pp];
Protect[$Packages];
]
]
]


(* ::Chapter::Closed:: *)
(*Generate Tests*)


(* ::Section:: *)
(*Model`Catalog`*)


(* ::Input:: *)
(*name = First@NotebookRead[PreviousCell[CellStyle -> "Section"]];*)
(*makeDefinitions[name];*)


(* ::Input:: *)
(*Begin[Evaluate@testContext];*)


(* ::Input:: *)
(*With[{context=context},*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Needs@context;*)
(*True*)
(*,"ConfirmResults"->confirm];*)
(*];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*MemberQ[$ContextPath,"FernandoDuarte`LongRunRisk`Model`Catalog`"]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*True if Keys are strings*)*)
(*And@@(StringQ/@Keys[models])*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*True if fields listed are strings*)*)
(*And@@(StringQ/@Flatten@({models[#]["name"],models[#]["shortname"],models[#]["bibRef"],models[#]["desc"]}&/@Keys[models]))*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*True if parameters evaluate to numbers*)*)
(*And@@(NumberQ/@Flatten[(models[#]["parameters"][[;;,2]]//.models[#]["parameters"])&/@Keys[models]])*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*True if equal to {x[t],sx[t]}*)*)
(*models["BY"]["stateVars"]==={FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`x [FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`t], FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`sx [FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`t]}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*True if it can find models listed*)*)
(*And@@(MemberQ[Keys[models],#]&/@{"BY","BKY"})*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*True if models is an association and each model inside models is itself an association*)*)
(*And@@(MatchQ[Association,#]&/@(Flatten@{Head[models],Head[models[#]]&/@Keys[models]}))*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*True if all exogenous variables are in context "FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`"*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*"stateVars"*)*)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`")&/@(Context/@Cases[models[#]["stateVars"],var_Symbol?(MemberQ[StringDrop[#,-2]&/@FernandoDuarte`LongRunRisk`Model`ExogenousEq`$exogenousVars,SymbolName[#]]&)[__]:>var,Infinity])))&/@Keys[models])*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*True if all shocks are in context "FernandoDuarte`LongRunRisk`Model`Shocks`"*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*"stateVars"*)*)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`Shocks`")&/@(Context/@Cases[models[#]["stateVars"],var_Symbol?(MatchQ[SymbolName[#],"eps"]&)[__][__]:>var,Infinity])))&/@Keys[models])*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*True if  all parameters are in context "FernandoDuarte`LongRunRisk`Model`Parameters`"*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*"parameters"*)*)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`Parameters`")&/@(Context/@Cases[models[#]["parameters"],var_Symbol?(MemberQ[FernandoDuarte`LongRunRisk`Model`Parameters`$parameters,SymbolName[#]]&):>var,Infinity])))&/@Keys[models])*)
(*,"ConfirmResults"->confirm];*)
(**)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*"stateVars"*)*)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`Parameters`")&/@(Context/@Cases[models[#]["stateVars"],var_Symbol?(MemberQ[FernandoDuarte`LongRunRisk`Model`Parameters`$parameters,SymbolName[#]]&):>var,Infinity])))&/@Keys[models])*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*True if state variables do not have any endogenous variables*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*"stateVars"*)*)
(*And@@(MatchQ[{},#]&/@(Cases[models[#]["stateVars"],var_Symbol?(MemberQ[StringDrop[#,-2]&/@FernandoDuarte`LongRunRisk`Model`EndogenousEq`$endogenousVars,SymbolName[#]]&)[__]:>var,Infinity]&/@Keys[models]))*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*True if modelsExtraInfo is an association and each model inside modelsExtraInfo is an association*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*"stateVars"*)*)
(*And@@{*)
(*AllTrue[modelsExtraInfo,AssociationQ],*)
(*AllTrue[modelsExtraInfo[#]&/@Keys[modelsExtraInfo],AssociationQ]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*True if models in modelsExtraInfo are a subset of those defined in models*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*"stateVars"*)*)
(*And@@{*)
(*SubsetQ[Keys[models],Keys[modelsExtraInfo]]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*if provided, initial guess for Ewc is a vector and for Epd is 2-dimensional array*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@( *)
(*Flatten@( *)
(*If[KeyExistsQ[modelsExtraInfo[#],"initialGuess"]*)
(*,*)
(*{*)
(*If[KeyExistsQ[modelsExtraInfo[#]["initialGuess"],"Ewc"],VectorQ["Ewc"/.modelsExtraInfo[#]["initialGuess"]] ,True]*)
(*,*)
(*If[KeyExistsQ[modelsExtraInfo[#]["initialGuess"],"Epd"],ArrayQ["Epd"/.modelsExtraInfo[#]["initialGuess"],2] ,True]*)
(*}*)
(*,*)
(*True*)
(*]&/@Keys[modelsExtraInfo]*)
(*)*)
(*)*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*End[];*)


(* ::Input:: *)
(*addBeginEnd[testFilePath,testContext];*)
(*{*)
(*tr[Evaluate@name]["TestReport"] ,*)
(*tr[Evaluate@name]["ActualOutput"] ,*)
(*tr[Evaluate@name]["ExpectedOutput"] ,*)
(*tr[Evaluate@name]["OutputTrueQ"]*)
(*}=runTests[testFilePath];*)
(*(*tableActualVsExpeected[testName_String];*)*)
(*cleanUp[];*)


(* ::Section:: *)
(*Model`EndogenousEq`*)


(* ::Input:: *)
(*name = First@NotebookRead[PreviousCell[CellStyle -> "Section"]];*)
(*makeDefinitions[name];*)


(* ::Input:: *)
(*Begin[Evaluate@testContext];*)


(* ::Input:: *)
(*With[{context=context},*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Needs@context;*)
(*True*)
(*,"ConfirmResults"->confirm];*)
(*]*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*should be true if pdeq can be found*)*)
(*	Not[Names["*pdeq"]==={}]*)
(*,"ConfirmResults"->False];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*all exogenous variables are in context "FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`"*)*)
(*And@@((#==="FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`")&/@(Context/@Cases[((#[t])&/@(Symbol/@$endogenousVars)),var_Symbol?(MemberQ[StringDrop[#,-2]&/@FernandoDuarte`LongRunRisk`Model`ExogenousEq`$exogenousVars,SymbolName[#]]&)[__]:>var,Infinity]))*)
(*,"ConfirmResults"->False];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*all shocks are in context "FernandoDuarte`LongRunRisk`Model`Shocks`"*)*)
(*And@@((#==="FernandoDuarte`LongRunRisk`Model`Shocks`")&/@(Context/@Cases[((#[t])&/@(Symbol/@$endogenousVars)),var_Symbol?(MatchQ[SymbolName[#],"eps"]&)[__][__]:>var,Infinity]))*)
(*,"ConfirmResults"->False];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*all parameters are in context "FernandoDuarte`LongRunRisk`Model`Parameters`"*)*)
(*And@@((#==="FernandoDuarte`LongRunRisk`Model`Parameters`")&/@(Context/@Cases[((#[t])&/@(Symbol/@$endogenousVars)),var_Symbol?(MemberQ[FernandoDuarte`LongRunRisk`Model`Parameters`$parameters,SymbolName[#]]&):>var,Infinity]))*)
(*,"ConfirmResults"->False];*)


(* ::Input:: *)
(*(*all endogenous variables are in context "FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`"*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@((#==="FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`")&/@(Context/@Cases[((#[t])&/@(Symbol/@$endogenousVars)),var_Symbol?(MemberQ[StringDrop[#,-2]&/@$endogenousVars,SymbolName[#]]&)[__]:>var,Infinity]))*)
(*,"ConfirmResults"->False];*)


(* ::Input:: *)
(*(*different contexts for t and eq vars*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*FreeQ[bondyieldeq[t,m],foo`t],*)
(*Not@FreeQ[bondyieldeq[t,m],t],*)
(*FreeQ[bondyieldeq[foo`t,m],t],*)
(*Not@FreeQ[bondyieldeq[foo`t,m],foo`t],*)
(*Not@(foo`bondyieldeq[t,m]===bondyieldeq[t,m]),*)
(*Not@(bondyieldeq[t,m]===bondyieldeq[foo`t,m])*)
(*}*)
(*,"ConfirmResults"->False];*)


(* ::Input:: *)
(*(*different contexts for m and eq vars*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*FreeQ[bondyieldeq[t,m],foo`m],*)
(*Not@FreeQ[bondyieldeq[t,m],m],*)
(*FreeQ[bondyieldeq[t,foo`m],m],*)
(*Not@FreeQ[bondyieldeq[t,foo`m],foo`m],*)
(*Not@(bondyieldeq[t,m]===bondyieldeq[t,foo`m])*)
(*}*)
(*,"ConfirmResults"->False];*)


(* ::Input:: *)
(*(*default values for arguments*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@*)
(*{*)
(*bondfweq[t,m]===bondfweq[t,m,1],*)
(*bondreteq[t,m]===bondreteq[t,m,1],*)
(*bondfwspreadeq[t,m]===bondfwspreadeq[t,m,1],*)
(*bondexcreteq[t,m]===bondexcreteq[t,m,1]*)
(*}*)
(*,"ConfirmResults"->False];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(**)
(*(*indices of coefficients are exact integers*)*)
(*coefwc=FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefwc;*)
(*coefpd=FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefpd;*)
(*coefb=FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefb;*)
(*coefnb=FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefnb;*)
(**)
(*hpd=Head@coefpd;*)
(*hb=Head@coefb;*)
(*hnb=Head@coefnb;*)
(**)
(*ch=Flatten@*)
(*{*)
(*{*)
(*coefwc[0],*)
(*N@coefwc[0],*)
(*N[coefwc[0]],*)
(*coefwc[0.],*)
(*N@coefwc[0.],*)
(*N[coefwc[0.]]*)
(*},*)
(**)
(*Table[*)
(*{*)
(*c[0],*)
(*N@c[0],*)
(*N[c[0]],*)
(*c[0.],*)
(*N@c[0.],*)
(*N[c[0.]]}*)
(*,*)
(*{c,{coefpd,coefb,coefnb}}*)
(*],*)
(**)
(*Table[*)
(*{*)
(*h[1][0],*)
(*N@h[1][0],*)
(*N[h[1][0]],*)
(*h[1][0.],*)
(*N@h[1][0.],*)
(*N[h[1][0.]],*)
(**)
(*h[0][1],*)
(*N@h[0][1],*)
(*N[h[0][1]],*)
(*h[0.][1],*)
(*N@h[0.][1],*)
(*N[h[0.][1]],*)
(**)
(*h[1.][0],*)
(*N@h[1.][0],*)
(*N[h[1.][0]],*)
(*h[1.][0.],*)
(*N@h[1.][0.],*)
(*N[h[1.][0.]],*)
(**)
(*h[0][1.],*)
(*N@h[0][1.],*)
(*N[h[0]][1.],*)
(*h[0.][1.],*)
(*N@h[0.][1.],*)
(*N[h[0.][1.]],*)
(**)
(*h[0][j],*)
(*N@h[0][j],*)
(*N[h[0][j]],*)
(*h[0.][j],*)
(*N@h[0.][j],*)
(*N[h[0.][j]],*)
(**)
(*h[j][0],*)
(*N@h[j][0],*)
(*N[h[j][0]],*)
(*h[j][0.],*)
(*N@h[j][0.],*)
(*N[h[j][0.]],*)
(**)
(*h[0][jj],*)
(*N@h[0][jj],*)
(*N[h[0][jj]],*)
(*h[0.][jj],*)
(*N@h[0.][jj],*)
(*N[h[0.][jj]],*)
(**)
(*h[jj][0],*)
(*N@h[jj][0],*)
(*N[h[jj][0]],*)
(*h[jj][0.],*)
(*N@h[jj][0.],*)
(*N[h[jj][0.]],*)
(**)
(*h[jj][kk],*)
(*N@h[jj][kk],*)
(*N[h[jj][kk]],*)
(**)
(*N@Table[*)
(*{h[ii][qq],*)
(*N@h[ii][qq],*)
(*N[h[ii][qq]]},*)
(*{ii,0,1},{qq,2,3}]*)
(*} /.jj->2/.kk->3*)
(*,*)
(*{h,{Head@coefpd,Head@coefb,Head@coefnb}}*)
(*]*)
(*};*)
(**)
(*And@@Flatten@{*)
(*{Not/@InexactNumberQ/@Select[Flatten@Cases[ch,x_[i_]:>i],NumberQ],*)
(*Not/@InexactNumberQ/@Select[Flatten@Cases[ch,x_[i_][j_]:>{i,j}],NumberQ]}*)
(*}*)
(**)
(*,"ConfirmResults"->False];*)


(* ::Input:: *)
(*End[];*)


(* ::Input:: *)
(*addBeginEnd[testFilePath,testContext];*)
(*{*)
(*tr[Evaluate@name]["TestReport"] ,*)
(*tr[Evaluate@name]["ActualOutput"] ,*)
(*tr[Evaluate@name]["ExpectedOutput"] ,*)
(*tr[Evaluate@name]["OutputTrueQ"]*)
(*}=runTests[testFilePath];*)
(*(*tableActualVsExpeected[testName_String];*)*)
(*cleanUp[];*)


(* ::Section:: *)
(*Model`ExogenousEq`*)


(* ::Input:: *)
(*name = First@NotebookRead[PreviousCell[CellStyle -> "Section"]];*)
(*makeDefinitions[name];*)


(* ::Input:: *)
(*Begin[Evaluate@testContext];*)


(* ::Input:: *)
(*With[{context=context},*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Needs@context;*)
(*True*)
(*,"ConfirmResults"->confirm];*)
(*];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*should be true if xeq can be found*)*)
(*	Not[Names["*xeq"]==={}]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*symbols all in context FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`*)*)
(*(*all exogenous variables are in context "FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`"*)*)
(*And@@{*)
(*MemberQ[DeleteDuplicates@(Context/@Cases[xeq[t],var_Symbol?(MatchQ[SymbolName[#],"x"]&)[___]:>var,Infinity]),"FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`"],*)
(*MemberQ[DeleteDuplicates@(Context/@Cases[pieq[t],var_Symbol?(MatchQ[SymbolName[#],"pi"]&)[___]:>var,Infinity]),"FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`"],*)
(*MemberQ[DeleteDuplicates@(Context/@Cases[pibareq[t],var_Symbol?(MatchQ[SymbolName[#],"pibar"]&)[___]:>var,Infinity]),"FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`"],*)
(*MemberQ[DeleteDuplicates@(Context/@Cases[sgeq[t],var_Symbol?(MatchQ[SymbolName[#],"sg"]&)[___]:>var,Infinity]),"FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`"],*)
(*MemberQ[DeleteDuplicates@(Context/@Cases[sxeq[t],var_Symbol?(MatchQ[SymbolName[#],"sx"]&)[___]:>var,Infinity]),"FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`"],*)
(*MemberQ[DeleteDuplicates@(Context/@Cases[sceq[t],var_Symbol?(MatchQ[SymbolName[#],"sc"]&)[___]:>var,Infinity]),"FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`"],*)
(*MemberQ[DeleteDuplicates@(Context/@Cases[speq[t],var_Symbol?(MatchQ[SymbolName[#],"sp"]&)[___]:>var,Infinity]),"FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`"],*)
(**)
(*Not[{}===Cases[Symbol/@Names["FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`*"],var_Symbol?(MatchQ[SymbolName[#],"dc"]&):>var,Infinity]],*)
(*Not[{}===Cases[Symbol/@Names["FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`*"],var_Symbol?(MatchQ[SymbolName[#],"dd"]&):>var,Infinity]],*)
(*MemberQ[DeleteDuplicates@(Context/@Cases[Symbol/@Names["FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`*"],var_Symbol?(MatchQ[SymbolName[#],"dc"]&):>var,Infinity]),"FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`"],*)
(*MemberQ[DeleteDuplicates@(Context/@Cases[Symbol/@Names["FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`*"],var_Symbol?(MatchQ[SymbolName[#],"dd"]&):>var,Infinity]),"FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`"]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*all exogenous variables are in context "FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`"*)*)
(*And@@((#==="FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`")&/@(Context/@Cases[(#[t])&/@(Symbol/@$exogenousVars),var_Symbol?(MemberQ[StringDrop[#,-2]&/@$exogenousVars,SymbolName[#]]&)[__]:>var,Infinity]))*)
(**)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*all shocks are in context "FernandoDuarte`LongRunRisk`Model`Shocks`"*)*)
(*And@@((#==="FernandoDuarte`LongRunRisk`Model`Shocks`")&/@(Context/@Cases[(#[t])&/@(Symbol/@$exogenousVars),var_Symbol?(MatchQ[SymbolName[#],"eps"]&)[__][__]:>var,Infinity]))*)
(**)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*all parameters are in context "FernandoDuarte`LongRunRisk`Model`Parameters`"*)*)
(*And@@((#==="FernandoDuarte`LongRunRisk`Model`Parameters`")&/@(Context/@Cases[(#[t])&/@(Symbol/@$exogenousVars),var_Symbol?(MemberQ[FernandoDuarte`LongRunRisk`Model`Parameters`$parameters,SymbolName[#]]&):>var,Infinity]))*)
(**)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*different contexts for t and eq vars*)*)
(*And@@{*)
(*FreeQ[xeq[t],foo`t],*)
(*Not@FreeQ[xeq[t],t],*)
(*FreeQ[xeq[foo`t],t],*)
(*Not@FreeQ[xeq[foo`t],foo`t],*)
(*Not@(foo`xeq[t]===xeq[t]),*)
(*Not@(xeq[t]===xeq[foo`t])*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*End[];*)


(* ::Input:: *)
(*addBeginEnd[testFilePath,testContext];*)
(*{*)
(*tr[Evaluate@name]["TestReport"] ,*)
(*tr[Evaluate@name]["ActualOutput"] ,*)
(*tr[Evaluate@name]["ExpectedOutput"] ,*)
(*tr[Evaluate@name]["OutputTrueQ"]*)
(*}=runTests[testFilePath];*)
(*(*tableActualVsExpeected[testName_String];*)*)
(*cleanUp[];*)


(* ::Section:: *)
(*Model`ProcessModels`*)


(* ::Input:: *)
(*name = First@NotebookRead[PreviousCell[CellStyle -> "Section"]];*)
(*makeDefinitions[name];*)


(* ::Input:: *)
(*Begin[Evaluate@testContext];*)


(* ::Input:: *)
(*With[{context=context},*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Needs@context;*)
(*True*)
(*,"ConfirmResults"->confirm];*)
(*]*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Needs["FernandoDuarte`LongRunRisk`Model`Catalog`"];*)
(*True*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*longTest = False; (*fast and partial coverage (False) or slow and full coverage (True)*)*)
(*True*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*	And@@{MemberQ[$ContextPath,"FernandoDuarte`LongRunRisk`Model`Catalog`"],*)
(*MemberQ[$ContextPath,"FernandoDuarte`LongRunRisk`Model`ProcessModels`"]}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*should be True if processModels, models can be found*)*)
(*	And@@{Not[Names["*processModels"]==={}],Not[Names["*models"]==={}]}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*models= Block[{$ContextPath = {}}, SetSymbolsContext[models]];*)*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Get@Get[FileNameJoin[{"FernandoDuarte/LongRunRisk","Models.wl"}]] ;*)
(*modelsTest=If[longTest,*)
(*FernandoDuarte`LongRunRisk`Model`Catalog`models,*)
(*KeyTake[FernandoDuarte`LongRunRisk`Model`Catalog`models,{"BY","BKY","NRC"}]*)
(*];*)
(*modelsP=If[longTest,*)
(*FernandoDuarte`LongRunRisk`Models,*)
(*KeyTake[FernandoDuarte`LongRunRisk`Models,{"BY","BKY","NRC"}]*)
(*];*)
(*True*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*Keys are strings*)*)
(*And@@(StringQ/@Keys[modelsP])*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*string fields*)*)
(*And@@(StringQ/@Flatten@({modelsP[#]["name"],modelsP[#]["shortname"],modelsP[#]["bibRef"],modelsP[#]["desc"],modelsP[#]["exogenousVars"],modelsP[#]["endogenousVars"]}&/@Keys[modelsP]))*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*(*parameters evaluate to numbers*)*)
(*And@@(NumberQ/@Flatten[Values[Association@modelsTest[#]["parameters"]//.modelsTest[#]["parameters"]//N]&/@(Keys@modelsTest)]),*)
(*And@@(NumberQ/@Flatten[Values[Association@modelsP[#]["parameters"]//.modelsP[#]["parameters"]//N]&/@(Keys@modelsP)])*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*(*can find some models*)*)
(*And@@(MemberQ[Keys[modelsTest],#]&/@{"BY","BKY"}),*)
(*And@@(MemberQ[Keys[modelsP],#]&/@(Keys@modelsP))*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*(*models, modelsP are associations*)*)
(*AllTrue[modelsTest,AssociationQ],*)
(*AllTrue[modelsP,AssociationQ],*)
(*(*each model inside models, modelsP are themselves an association*)*)
(*AllTrue[modelsTest[#]&/@Keys[modelsTest],AssociationQ],*)
(*AllTrue[modelsP[#]&/@Keys[modelsP],AssociationQ]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*If[longTest,*)
(*(*all exogenous variables are in context "FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`"*)*)
(*And@@{*)
(*(*"stateVars"*)*)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`")&/@(Context/@Cases[modelsP[#]["stateVars"],var_Symbol?(MemberQ[StringDrop[#,-2]&/@FernandoDuarte`LongRunRisk`Model`ExogenousEq`$exogenousVars,SymbolName[#]]&)[__]:>var,Infinity])))&/@Keys[modelsP]),*)
(**)
(*(*"modelAssumptions"*)*)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`")&/@(Context/@Cases[modelsP[#]["modelAssumptions"],var_Symbol?(MemberQ[StringDrop[#,-2]&/@FernandoDuarte`LongRunRisk`Model`ExogenousEq`$exogenousVars,SymbolName[#]]&)[__]:>var,Infinity])))&/@Keys[modelsP]),*)
(**)
(*(*"exogenousEq"*)*)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`")&/@(Context/@Cases[modelsP[#]["exogenousEq"],var_Symbol?(MemberQ[StringDrop[#,-2]&/@FernandoDuarte`LongRunRisk`Model`ExogenousEq`$exogenousVars,SymbolName[#]]&)[__]:>var,Infinity])))&/@Keys[modelsP]),*)
(**)
(*(*"endogenousEq"*)*)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`")&/@(Context/@Cases[modelsP[#]["endogenousEq"],var_Symbol?(MemberQ[StringDrop[#,-2]&/@FernandoDuarte`LongRunRisk`Model`ExogenousEq`$exogenousVars,SymbolName[#]]&)[__]:>var,Infinity])))&/@Keys[modelsP])*)
(*}*)
(*,*)
(*True*)
(*]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*If[longTest,*)
(*(*all shocks are in context "FernandoDuarte`LongRunRisk`Model`Shocks`"*)*)
(*And@@{*)
(*(*"stateVars"*)*)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`Shocks`")&/@(Context/@Cases[modelsP[#]["stateVars"],var_Symbol?(MatchQ[SymbolName[#],"eps"]&)[__][__]:>var,Infinity])))&/@Keys[modelsP]),*)
(**)
(*(*"modelAssumptions"*)*)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`Shocks`")&/@(Context/@Cases[modelsP[#]["modelAssumptions"],var_Symbol?(MatchQ[SymbolName[#],"eps"]&)[__][__]:>var,Infinity])))&/@Keys[modelsP]),*)
(**)
(*(*"exogenousEq"*)*)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`Shocks`")&/@(Context/@Cases[modelsP[#]["exogenousEq"],var_Symbol?(MatchQ[SymbolName[#],"eps"]&)[__][__]:>var,Infinity])))&/@Keys[modelsP]),*)
(**)
(*(*"endogenousEq"*)*)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`Shocks`")&/@(Context/@Cases[modelsP[#]["endogenousEq"],var_Symbol?(MatchQ[SymbolName[#],"eps"]&)[__][__]:>var,Infinity])))&/@Keys[modelsP])*)
(*}*)
(*,*)
(*True*)
(*]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*If[longTest,*)
(*(*all parameters are in context "FernandoDuarte`LongRunRisk`Model`Parameters`"*)*)
(*And@@{*)
(*(*"parameters"*)*)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`Parameters`")&/@(Context/@Cases[modelsP[#]["parameters"],var_Symbol?(MemberQ[FernandoDuarte`LongRunRisk`Model`Parameters`$parameters,SymbolName[#]]&):>var,Infinity])))&/@Keys[modelsP]),*)
(**)
(*(*"stateVars"*)*)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`Parameters`")&/@(Context/@Cases[modelsP[#]["stateVars"],var_Symbol?(MemberQ[FernandoDuarte`LongRunRisk`Model`Parameters`$parameters,SymbolName[#]]&):>var,Infinity])))&/@Keys[modelsP]),*)
(**)
(*(*"modelAssumptions"*)*)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`Parameters`")&/@(Context/@Cases[modelsP[#]["modelAssumptions"],var_Symbol?(MemberQ[FernandoDuarte`LongRunRisk`Model`Parameters`$parameters,SymbolName[#]]&):>var,Infinity])))&/@Keys[modelsP]),*)
(**)
(*(*"exogenousEq"*)*)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`Parameters`")&/@(Context/@Cases[modelsP[#]["exogenousEq"],var_Symbol?(MemberQ[FernandoDuarte`LongRunRisk`Model`Parameters`$parameters,SymbolName[#]]&):>var,Infinity])))&/@Keys[modelsP]),*)
(**)
(*(*"endogenousEq"*)*)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`Parameters`")&/@(Context/@Cases[modelsP[#]["endogenousEq"],var_Symbol?(MemberQ[FernandoDuarte`LongRunRisk`Model`Parameters`$parameters,SymbolName[#]]&):>var,Infinity])))&/@Keys[modelsP])*)
(*}*)
(*,*)
(*True*)
(*]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*If[longTest,*)
(*(*all endogenous variables are in context "FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`"*)*)
(*(*"modelAssumptions"*)*)
(*And@@{*)
(**)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`")&/@(Context/@Cases[modelsP[#]["modelAssumptions"],var_Symbol?(MemberQ[StringDrop[#,-2]&/@FernandoDuarte`LongRunRisk`Model`EndogenousEq`$endogenousVars,SymbolName[#]]&)[__]:>var,Infinity])))&/@Keys[modelsP]),*)
(**)
(*(*"endogenousEq"*)*)
(*And@@((And@@((#==="FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`")&/@(Context/@Cases[modelsP[#]["endogenousEq"],var_Symbol?(MemberQ[StringDrop[#,-2]&/@FernandoDuarte`LongRunRisk`Model`EndogenousEq`$endogenousVars,SymbolName[#]]&)[__]:>var,Infinity])))&/@Keys[modelsP])*)
(*}*)
(*,*)
(*True*)
(*]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*If[longTest,*)
(*(*all coefficients of wc, pd, bond ratios are in context "FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`"*)*)
(*coefs=Alternatives@@SymbolName/@{FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefwc,Head@FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefpd,Head@FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefb,Head@FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefnb};*)
(**)
(*And@@((#==="FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`")&/@Flatten@(Cases[modelsP[#]["modelAssumptions"],(var_Symbol?(MatchQ[SymbolName[#],coefs]&)|var_Symbol?(MatchQ[SymbolName[#],coefs]&)[__]):>Context[var],Infinity]&/@Keys[modelsP]))*)
(*,*)
(*True*)
(*]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*should not have any endogenous variables*)*)
(*(*"stateVars"*)*)
(*And@@{*)
(**)
(*And@@(MatchQ[{},#]&/@(Cases[modelsP[#]["stateVars"],var_Symbol?(MemberQ[StringDrop[#,-2]&/@FernandoDuarte`LongRunRisk`Model`EndogenousEq`$endogenousVars,SymbolName[#]]&)[__]:>var,Infinity]&/@Keys[modelsP])),*)
(**)
(**)
(*(*"exogenousEq"*)*)
(*And@@(MatchQ[{},#]&/@(Cases[modelsP[#]["exogenousEq"],var_Symbol?(MemberQ[StringDrop[#,-2]&/@FernandoDuarte`LongRunRisk`Model`EndogenousEq`$endogenousVars,SymbolName[#]]&)[__]:>var,Infinity]&/@Keys[modelsP]))*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*keys and shortname are preserved*)*)
(*And@@*)
(*{*)
(*SubsetQ[Keys[modelsTest],Keys[modelsP]],*)
(*SubsetQ[modelsTest[#]["shortname"]&/@Keys[modelsTest],modelsP[#]["shortname"]&/@Keys[modelsP]]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*stateVars are functions of one variable (time)*)*)
(*And@@{*)
(*And@@(MatchQ[Function,#]&/@(Head/@((modelsP[#]["stateVars"])&/@Keys[modelsP]))),*)
(*And@@(MatchQ[List,#]&/@(Head/@((modelsP[#]["stateVars"][t])&/@Keys[modelsP]))),*)
(*And@@(MatchQ[1,#]&/@(Length/@((modelsP[#]["stateVars"][[1]])&/@Keys[modelsP]))),*)
(*And@@(MatchQ["t",#]&/@((SymbolName@@modelsP[#]["stateVars"][[1]])&/@Keys[modelsP])),*)
(*(*evaluating the function at FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`t gives the same as "stateVars" in models*)*)
(*((modelsP[#]["stateVars"][FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`t])&/@Keys[modelsP])===((modelsTest[#]["stateVars"])&/@Keys[modelsP])*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*numStocks is a number*)*)
(*And@@(NumberQ/@(modelsP[#]["numStocks"]&/@(Keys@modelsP)))*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*compare to some hand-written expressions known to be correct*)*)
(*modelPNRC=modelsP["NRC"];*)
(*And@@{*)
(**)
(*(pi[myContext`t]/.Normal@modelPNRC["exogenousEq"])===(FernandoDuarte`LongRunRisk`Model`Parameters`mup+FernandoDuarte`LongRunRisk`Model`Parameters`rhop (-FernandoDuarte`LongRunRisk`Model`Parameters`mup+FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[-1+myContext`t])+FernandoDuarte`LongRunRisk`Model`Parameters`xip FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][-1+myContext`t]+FernandoDuarte`LongRunRisk`Model`Parameters`phip FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][myContext`t]),*)
(**)
(*(eps["dc"][t]/.modelPNRC["exogenousEq"])===eps["dc"][t],*)
(**)
(*(dd[t,i]/.Normal@modelPNRC["exogenousEq"])===(FernandoDuarte`LongRunRisk`Model`Parameters`mud[i]+(-FernandoDuarte`LongRunRisk`Model`Parameters`mup+FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[-1+t]) FernandoDuarte`LongRunRisk`Model`Parameters`rhodp[i]+FernandoDuarte`LongRunRisk`Model`Parameters`phidc[i] FernandoDuarte`LongRunRisk`Model`Shocks`eps["dc"][t]+FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`sg[-2+t] FernandoDuarte`LongRunRisk`Model`Parameters`xid[i] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][-1+t]),*)
(**)
(*(wc[t]/.Normal@modelPNRC["endogenousEq"])===(FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`A[0]+FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`A[1] (-FernandoDuarte`LongRunRisk`Model`Parameters`mup+FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[t])+FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`A[4] (-FernandoDuarte`LongRunRisk`Model`Parameters`Esg+FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`sg[t])+FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`A[5] (-FernandoDuarte`LongRunRisk`Model`Parameters`Esg^2-FernandoDuarte`LongRunRisk`Model`Parameters`phig^2/(1-FernandoDuarte`LongRunRisk`Model`Parameters`rhog^2)+FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`sg[t]^2)+FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`A[3] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t]+FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`A[2] FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`sg[-1+t] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t]),*)
(**)
(*(pd[t,i]/.Normal@modelPNRC["endogenousEq"])===(FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`B[i][0]+(-FernandoDuarte`LongRunRisk`Model`Parameters`mup+FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[t]) FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`B[i][1]+(-FernandoDuarte`LongRunRisk`Model`Parameters`Esg+FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`sg[t]) FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`B[i][4]+(-FernandoDuarte`LongRunRisk`Model`Parameters`Esg^2-FernandoDuarte`LongRunRisk`Model`Parameters`phig^2/(1-FernandoDuarte`LongRunRisk`Model`Parameters`rhog^2)+FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`sg[t]^2) FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`B[i][5]+FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`sg[-1+t] FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`B[i][2] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t]+FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`B[i][3] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t]),*)
(**)
(*(bondexcret[t,i]/.Normal@modelPNRC["endogenousEq"])===(FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`bondret[t,i,1]-FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`bondyield[-1+t,1]),*)
(**)
(*(bondexcret[t,i]/.Normal@modelPNRC["endogenousEq"]/.Normal@modelPNRC["endogenousEq"])===(FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`bond[-1+t,1]-FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`bond[-1+t,i]+FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`bond[t,-1+i])*)
(**)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*endogenous variables mapped repeatedly using "endogenousEq" has no endogenous variables*)*)
(*And@@{*)
(**)
(*And@@( *)
(*MatchQ[{},#]&/@(Cases[wc[t]//.Normal@modelsP[#]["endogenousEq"],var_Symbol?(MemberQ[StringDrop[#,-2]&/@FernandoDuarte`LongRunRisk`Model`EndogenousEq`$endogenousVars,SymbolName[#]]&)[__]:>var,Infinity]&/@Keys[modelsP])*)
(*),*)
(**)
(*(*endogenous variables mapped repeatedly using "endogenousEq" has exogenous variables that are all in context "FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`"*)*)
(*And@@(MatchQ[#,"FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`"]&/@(Flatten@(Cases[wc[t]//.Normal@modelsP[#]["endogenousEq"],var_Symbol?(MemberQ[StringDrop[#,-2]&/@FernandoDuarte`LongRunRisk`Model`ExogenousEq`$exogenousVars,SymbolName[#]]&)[__]:>Context@var,Infinity]&/@Keys[modelsP]))),*)
(**)
(*(*endogenous variables mapped repeatedly using "endogenousEq" has parameters that are all in context "FernandoDuarte`LongRunRisk`Model`Parameters`"*)*)
(*And@@(MatchQ[#,"FernandoDuarte`LongRunRisk`Model`Parameters`"]&/@(Flatten@(Cases[wc[t]//.Normal@modelsP[#]["endogenousEq"],var_Symbol?(MemberQ[FernandoDuarte`LongRunRisk`Model`Parameters`$parameters,SymbolName[#]]&):>Context@var,Infinity]&/@Keys[modelsP]))),*)
(**)
(*(*endogenous variables mapped repeatedly using "endogenousEq" has shocks that are all in context "FernandoDuarte`LongRunRisk`Model`Shocks`"*)*)
(*And@@(MatchQ[#,"FernandoDuarte`LongRunRisk`Model`Shocks`"]&/@(Flatten@(Cases[wc[t]//.Normal@modelsP[#]["endogenousEq"],var_Symbol?(MatchQ[SymbolName[#],"eps"]&)[__][__]:>Context@var,Infinity]&/@Keys[modelsP])))*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*endogenous variables mapped repeatedly using "endogenousEq" has no endogenous variables*)*)
(*And@@{*)
(**)
(*And@@( *)
(*MatchQ[{},#]&/@(Cases[bondexcret[t,i]//.Normal@modelsP[#]["endogenousEq"],var_Symbol?(MemberQ[StringDrop[#,-2]&/@FernandoDuarte`LongRunRisk`Model`EndogenousEq`$endogenousVars,SymbolName[#]]&)[__]:>var,Infinity]&/@Keys[modelsP])*)
(*),*)
(**)
(*(*endogenous variables mapped repeatedly using "endogenousEq" has exogenous variables that are all in context "FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`"*)*)
(*And@@(MatchQ[#,"FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`"]&/@(Flatten@(Cases[bondexcret[t,i]//.Normal@modelsP[#]["endogenousEq"],var_Symbol?(MemberQ[StringDrop[#,-2]&/@FernandoDuarte`LongRunRisk`Model`ExogenousEq`$exogenousVars,SymbolName[#]]&)[__]:>Context@var,Infinity]&/@Keys[modelsP]))),*)
(**)
(*(*endogenous variables mapped repeatedly using "endogenousEq" has parameters that are all in context "FernandoDuarte`LongRunRisk`Model`Parameters`"*)*)
(*And@@(MatchQ[#,"FernandoDuarte`LongRunRisk`Model`Parameters`"]&/@(Flatten@(Cases[bondexcret[t,i]//.Normal@modelsP[#]["endogenousEq"],var_Symbol?(MemberQ[FernandoDuarte`LongRunRisk`Model`Parameters`$parameters,SymbolName[#]]&):>Context@var,Infinity]&/@Keys[modelsP]))),*)
(**)
(*(*endogenous variables mapped repeatedly using "endogenousEq" has shocks that are all in context "FernandoDuarte`LongRunRisk`Model`Shocks`"*)*)
(*And@@(MatchQ[#,"FernandoDuarte`LongRunRisk`Model`Shocks`"]&/@(Flatten@(Cases[bondexcret[t,i]//.Normal@modelsP[#]["endogenousEq"],var_Symbol?(MatchQ[SymbolName[#],"eps"]&)[__][__]:>Context@var,Infinity]&/@Keys[modelsP])))*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*AllTrue[Head/@(Keys@modelsP["BKY"]["exogenousEq"]),MatchQ[#,PatternTest]&],*)
(*AllTrue[Head/@(Keys@modelsP["BKY"]["endogenousEq"]),MatchQ[#,PatternTest]&]*)
(*}*)
(*,"ConfirmResults"->confirm];*)
(**)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*exogenousEq and endogenousEq evaluate expressions that are exogenous or endogenous variables*)*)
(*And@@{*)
(**)
(*And@@(Not/@((Head[dc[t]]===Head[(dc[t]/.Normal[Join[modelsP[#]["exogenousEq"],modelsP[#]["endogenousEq"]]])])&/@Keys[modelsP])),*)
(**)
(*And@@(Not/@((Head[dd[t,i]]===Head[(dd[t,i]/.Normal[Join[modelsP[#]["exogenousEq"],modelsP[#]["endogenousEq"]]])])&/@Keys[modelsP])),*)
(**)
(*And@@(Not/@((Head[wc[t]]===Head[(wc[t]/.Normal[Join[modelsP[#]["exogenousEq"],modelsP[#]["endogenousEq"]]])])&/@Keys[modelsP])),*)
(**)
(*And@@(Not/@((Head[sdf[t]]===Head[(sdf[t]/.Normal[Join[modelsP[#]["exogenousEq"],modelsP[#]["endogenousEq"]]])])&/@Keys[modelsP])),*)
(**)
(*And@@(Not/@((Head[bondyield[t]]===Head[(bondyield[t]/.Normal[Join[modelsP[#]["exogenousEq"],modelsP[#]["endogenousEq"]]])])&/@Keys[modelsP]))*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*exogenousEq and endogenousEq do not evaluate expressions that are neither exogenous nor endogenous variables*)*)
(*And@@{*)
(*And@@((Head[notVar[t]]===Head[(notVar[t]/.Normal[Join[modelsP[#]["exogenousEq"],modelsP[#]["endogenousEq"]]])])&/@Keys[modelsP])*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*If[longTest,*)
(*(*shortname different from model key*)*)
(*modelBY=modelsTest["BY"];*)
(*modelBKY=modelsTest["BKY"];*)
(*modelBKYP=processModels[<|"BKY"->modelBKY|>];*)
(*modelBYP=processModels[<|"BY"->modelBY|>];*)
(*newModels=<|"myModel"->modelBKY,"BY"->modelBY|>;*)
(*newModelsSameName=<|"BY"->modelBY|>;*)
(*newModelsRename=<|"myModel"->modelBY|>;*)
(**)
(*newModelsP=processModels[newModels];*)
(*newModelsSameNameP=processModels[newModelsSameName];*)
(*newModelsRenameP=processModels[newModelsRename];*)
(**)
(*And@@{*)
(*KeyDrop[#,"coeffsSolution"]&@newModelsP["myModel"]===KeyDrop[#,"coeffsSolution"]&@modelBKYP["BKY"],*)
(*KeyDrop[#,"coeffsSolution"]&@newModelsP["BY"]===KeyDrop[#,"coeffsSolution"]&@modelBYP["BY"],*)
(*KeyDrop[#,"coeffsSolution"]&@newModelsSameNameP["BY"]===KeyDrop[#,"coeffsSolution"]&@modelBYP["BY"],*)
(*KeyDrop[#,"coeffsSolution"]&@newModelsRenameP["myModel"]===KeyDrop[#,"coeffsSolution"]&@modelBYP["BY"]*)
(*}*)
(*,*)
(*True*)
(*]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*numeric solution for coefficients only has numbers*)*)
(*And@@Flatten@{*)
(*(And@@(NumberQ/@(Values@modelsP[#]["coeffsSolutionN"])))&/@Keys[modelsP]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*End[];*)


(* ::Input:: *)
(*addBeginEnd[testFilePath,testContext];*)
(*{*)
(*tr[Evaluate@name]["TestReport"] ,*)
(*tr[Evaluate@name]["ActualOutput"] ,*)
(*tr[Evaluate@name]["ExpectedOutput"] ,*)
(*tr[Evaluate@name]["OutputTrueQ"]*)
(*}=runTests[testFilePath];*)
(*(*tableActualVsExpeected[testName_String];*)*)
(*cleanUp[];*)


(* ::Section:: *)
(*Model`Shocks`*)


(* ::Input:: *)
(*name = First@NotebookRead[PreviousCell[CellStyle -> "Section"]];*)
(*makeDefinitions[name];*)


(* ::Input:: *)
(*Begin[Evaluate@testContext];*)


(* ::Input:: *)
(*With[{context=context},*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Needs@context;*)
(*True*)
(*,"ConfirmResults"->confirm];*)
(*];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*	MemberQ[$ContextPath,"FernandoDuarte`LongRunRisk`Model`Shocks`"]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*should be true if rulesE can be found*)*)
(*	Not[Names["*rulesE"]==={}]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*shocks have zero means*)*)
(*And@@( *)
(*Flatten@{*)
(*	Table[*)
(*		(eps[f][t]/.rulesE[t])===0*)
(*		,{f,{"x","dc","pi","pibar","sg","sx","sc","sp"}}*)
(*	]*)
(*,*)
(*	Table[*)
(*		(eps["dd"][t,ii]/.rulesE[t])===0*)
(*		,{ii,{1,i,j}}*)
(*	]*)
(*}*)
(*)*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*shocks have variance equal to one*)*)
(*And@@( *)
(*Flatten@{*)
(*	Table[*)
(*		(eps[f][t]^2/.rulesE[t])===1*)
(*		,{f,{"x","dc","pi","pibar","sg","sx","sc","sp"}}*)
(*	]*)
(*	,*)
(*	Table[*)
(*		(eps["dd"][t,ii]^2/.rulesE[t])===1*)
(*		,{ii,{1,i,j}}*)
(*	]*)
(*}*)
(*)*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*shocks have zero third moment*)*)
(*And@@( *)
(*Flatten@{*)
(*	Table[*)
(*		(eps[f][t]^3/.rulesE[t])===0*)
(*		,{f,{"x","dc","pi","pibar","sg","sx","sc","sp"}}*)
(*	],*)
(*	Table[*)
(*		(eps["dd"][t,ii]^3/.rulesE[t])===0*)
(*		,{ii,{1,i,j}}*)
(*	]*)
(*}*)
(*)*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*shocks have fourth moment equal to three*)*)
(*And@@( *)
(*Flatten@{*)
(*	Table[*)
(*		(eps[f][t]^4/.rulesE[t])===3*)
(*		,{f,{"x","dc","pi","pibar","sg","sx","sc","sp"}}*)
(*	]*)
(*	,*)
(*	Table[*)
(*		(eps["dd"][t,ii]^4/.rulesE[t])===3*)
(*		,{ii,{1,i,j}}*)
(*	]*)
(*}*)
(*)*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*shocks are uncorrelated*)*)
(*And@@( *)
(*Flatten@{*)
(*	Table[*)
(*		0===If[f===g,0,eps[f][t]*eps[g][t]/.rulesE[t]]*)
(*		,{f,{"x","dc","pi","pibar","sg","sx","sc","sp"}}*)
(*		,{g,{"x","dc","pi","pibar","sg","sx","sc","sp"}}*)
(*	]*)
(*	,*)
(*	Table[*)
(*		0===(eps["dd"][t,ii]*eps[f][t]/.rulesE[t])*)
(*		,{ii,{1,i,j}}*)
(*		,{f,{"x","pi","pibar","sg","sx","sc","sp"}}*)
(*	]*)
(*}*)
(*)*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*taugd works as correlation b/w shocks to consumption and dividends*)*)
(*(StringDelete[#,"FernandoDuarte"|"`"~~__~~"`"]&/@Table[*)
(*ToString@(eps["dd"][t,ii]*eps["dc"][t]/.rulesE[t])*)
(*,{ii,{1,i,j}}*)
(*])==={"taugd[1]","taugd[i]","taugd[j]"}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*should all return true, confirming that rulesE returns same expression unevaluated*)*)
(*And@@( *)
(*Flatten@{*)
(*	Table[*)
(*		(expr/.rulesE[t])===expr*)
(*		,{expr,Table[eps[f][t+1],{f,{"x","dc","pi","pibar","sg","sx","sc","sp"}}]}*)
(*	]*)
(*	,*)
(*	Table[*)
(*		(expr/.rulesE[t])===expr*)
(*		,{expr,Table[eps[ToExpression@f][t],{f,{"x","dc","pi","pibar","sg","sx","sc","sp"}}]}*)
(*	]*)
(*	,*)
(*	Table[*)
(*		(expr/.rulesE[t])===expr*)
(*		,{expr,{eps["dd"][t+1,i],eps[dd][t,i]}}*)
(*	]*)
(*}*)
(*)*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*should all return true, confirming that rulesE returns same expression unevaluated*)*)
(*And@@( *)
(*Flatten@{*)
(*	Table[*)
(*		(expr/.rulesE[t])===expr*)
(*		,{expr,Table[eps[f],{f,{"x","dc","pi","pibar","sg","sx","sc","sp"}}]}*)
(*	]*)
(*	,*)
(*	Table[*)
(*		(eps["dd"]/.rulesE[t])===eps["dd"]*)
(*		,{ii,{1,i,j}}*)
(*	]*)
(*}*)
(*)*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*should all return true, confirming that rulesE returns same expression unevaluated*)*)
(*And@@( *)
(*Flatten@{*)
(*	Table[*)
(*		(expr/.rulesE[t])===expr*)
(*		,{expr,Table[eps[f],{f,{"xx","adc","p","rhobar","ssg","ssx","sdc","spi"}}]}*)
(*	]*)
(*	,*)
(*	Table[*)
(*		(eps["ddd"]/.rulesE[t])===eps["ddd"]*)
(*		,{ii,{1,i,j}}*)
(*	]*)
(*}*)
(*)*)
(*,"ConfirmResults"->confirm];*)
(**)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*should all return true, confirming that rulesE returns same expression unevaluated*)*)
(*And@@( *)
(*Flatten@{*)
(*	Table[*)
(*		(expr/.rulesE[t])===expr*)
(*		,{expr,Table[eps[f][tt],{f,{"xx","adc","p","rhobar","ssg","ssx","sdc","spi"}},{tt,{t+1,t-1,s,t+h}}]}*)
(*	]*)
(*	,*)
(*	Table[*)
(*		(expr/.rulesE[t])===expr*)
(*		,{expr,Table[eps["dd"][tt,ii],{ii,{1,i,j}},{tt,{t+1,t-1,s,t+h}}]}*)
(*	]*)
(*}*)
(*)*)
(*,"ConfirmResults"->confirm];*)
(**)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*rulesE works for any context*)*)
(*And@@( *)
(*Flatten@*)
(*{*)
(*	Table[*)
(*		(NewContext`eps[f][t]/.rulesE[t])===0*)
(*		,{f,{"x","dc","pi","pibar","sg","sx","sc","sp"}}*)
(*	]*)
(*,*)
(*	Table[*)
(*		(NewContext`eps["dd"][t,ii]/.rulesE[t])===0*)
(*		,{ii,{1,i,j}}*)
(*	]*)
(*}*)
(*)*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*rulesE works for original context*)*)
(*And@@( *)
(*Flatten@{*)
(*	Table[*)
(*	(FernandoDuarte`LongRunRisk`Model`Shocks`Private`eps[f][t]^2/.rulesE[t])===1*)
(*		,{f,{"x","dc","pi","pibar","sg","sx","sc","sp"}}*)
(*	]*)
(*	,*)
(*	Table[		(FernandoDuarte`LongRunRisk`Model`Shocks`Private`eps["dd"][t,ii]^2/.rulesE[t])===1*)
(*		,{ii,{1,i,j}}*)
(*	]*)
(*}*)
(*)*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*End[];*)


(* ::Input:: *)
(*addBeginEnd[testFilePath,testContext];*)
(*{*)
(*tr[Evaluate@name]["TestReport"] ,*)
(*tr[Evaluate@name]["ActualOutput"] ,*)
(*tr[Evaluate@name]["ExpectedOutput"] ,*)
(*tr[Evaluate@name]["OutputTrueQ"]*)
(*}=runTests[testFilePath];*)
(*(*tableActualVsExpeected[testName_String];*)*)
(*cleanUp[];*)


(* ::Section:: *)
(*ComputationalEngine`ComputeConditionalExpectations`*)


(* ::Input:: *)
(*name = First@NotebookRead[PreviousCell[CellStyle -> "Section"]];*)
(*makeDefinitions[name];*)


(* ::Input:: *)
(*Begin[Evaluate@testContext];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Needs@"FernandoDuarte`LongRunRisk`";*)
(*Needs@"PacletizedResourceFunctions`";*)
(*True*)
(*,"ConfirmResults"->confirm]; *)


(* ::Input:: *)
(*With[{context=context},*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Needs@context;*)
(*(*$ContextAliases["ce`"]="FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeConditionalExpectations`Private`";*)*)
(*$ContextPath = DeleteDuplicates@Prepend[$ContextPath,"FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeConditionalExpectations`Private`"];*)
(*True*)
(*,"ConfirmResults"->confirm]; *)
(*];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*MemberQ[$ContextPath,"FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeConditionalExpectations`"]*)
(*}*)
(*,"ConfirmResults"->confirm]; *)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*should be true if uncondE, lagStateVarst can be found*)*)
(*And@@{*)
(*Not[Names["*ev"]==={}],*)
(*Not[Names["lagStateVarst"]==={}]*)
(*}*)
(*,"ConfirmResults"->confirm]; *)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Get@Get[FileNameJoin[{"FernandoDuarte/LongRunRisk","Models.wl"}]];*)
(*msp=FernandoDuarte`LongRunRisk`Models;*)
(*modBY=msp["BY"];*)
(*modNRC=msp["NRC"];*)
(*True*)
(*,"ConfirmResults"->confirm]; *)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*ev[eps["pi"][t+1]pi[t+1],t-1,modNRC]===FernandoDuarte`LongRunRisk`Model`Parameters`phip*)
(*,"ConfirmResults"->confirm]; *)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*0===(ev[dd[t+1,i]pi[t+1],t,modNRC]-((mup+rhop(pi[t]-mup)+  xip eps["pi"][t] )(mud[i]+rhodp[i](pi[t]-mup)+ xid[i]sg[t-1] eps["pi"][t])  )//Simplify),*)
(*0===(ev[dd[t+1,i]dc[t+1],t,modNRC]-((mud[i]+rhodp[i](pi[t]-mup)+ xid[i]sg[t-1] eps["pi"][t])(muc+rhocp (pi[t]-mup)+ xic sg[t-1]eps["pi"][t] ) + phic phidc[i])//Simplify),*)
(*0===(ev[sg[t+3]dc[t+2]pi[t+1],t,modNRC]-((Esg+rhog^3 (sg[t]-Esg))((mup+rhop(pi[t]-mup)+  xip eps["pi"][t] )(muc+rhocp rhop(pi[t]-mup)+rhocp xip eps["pi"][t]) +rhocp phip^2+xic phip sg[t]))//Simplify),*)
(*0===(ev[pi[t+2]pi[t+1],t,modNRC]-((mup+rhop(pi[t]-mup)+  xip eps["pi"][t] )(mup+ rhop^2 (pi[t]-mup)+rhop xip eps["pi"][t]) +rhop phip^2+xip phip )//Simplify),*)
(*0===(ev[dc[t+2]pi[t+1],t+1,modNRC]-pi[t+1]ev[dc[t+2],t+1,modNRC] //Simplify),*)
(*0===(ev[dc[t+2]pi[t+1],t,modNRC]-((mup+rhop(pi[t]-mup)+  xip eps["pi"][t] )(muc+rhocp rhop(pi[t]-mup)+rhocp xip eps["pi"][t]) +rhocp phip^2+xic phip sg[t] )//Simplify),*)
(*0===(ev[dc[t+1]pi[t+1],t,modNRC]-(mup+rhop(pi[t]-mup)+  xip eps["pi"][t] )(muc+rhocp (pi[t]-mup)+ xic sg[t-1]eps["pi"][t] ) //Simplify),*)
(*0===(ev[dc[t]pi[t],t,modNRC]-pi[t](muc+rhocp (pi[t-1]-mup)+ xic sg[t-2]eps["pi"][t-1] +phic eps["dc"][t]) //Simplify),*)
(*0===(ev[dc[t-1]pi[t-1],t,modNRC]-pi[t-1](muc+rhocp (pi[t-2]-mup)+ xic sg[t-3]eps["pi"][t-2]  +phic eps["dc"][t-1]) //Simplify),*)
(*0===(ev[dc[t-2]pi[t-2],t,modNRC]-pi[t-2](muc+rhocp (pi[t-3]-mup)+ xic sg[t-4]eps["pi"][t-3]  +phic eps["dc"][t-2]) //Simplify),0===(ev[sg[t+2]sg[t+1]^2,t,modNRC]-( (1-rhog)Esg ev[sg[t+1]^2,t,modNRC]+rhog ev[sg[t+1]^3,t,modNRC]) //Simplify),*)
(*0===(ev[sg[t+2]sg[t+1]^2,t,modNRC]-( (1-rhog)Esg((Esg + rhog (sg[t]-Esg))^2+phig^2)+rhog ( (Esg + rhog * (sg[t]-Esg))^3+3phig^2 (Esg + rhog * (sg[t]-Esg)) )) //Simplify),*)
(*0===(ev[sg[t+3]sg[t+1]^2,t,modNRC]-( (1-rhog^2)Esg ev[sg[t+1]^2,t,modNRC]+rhog^2 ev[sg[t+1]^3,t,modNRC]) //Simplify),*)
(*0===(ev[sg[t+3]sg[t+1]^2,t,modNRC]-( (1-rhog^2)Esg((Esg + rhog (sg[t]-Esg))^2+phig^2)+rhog^2 ( (Esg + rhog * (sg[t]-Esg))^3+3phig^2 (Esg + rhog * (sg[t]-Esg)) )) //Simplify),*)
(*0===(ev[sg[t+2]sg[t+1],t,modNRC]-( (Esg + rhog^2 * (sg[t]-Esg))(Esg + rhog * (sg[t]-Esg))+rhog phig^2 ) //Simplify),*)
(*0===(ev[sg[t+3]sg[t+1],t,modNRC]-( (Esg + rhog^3 * (sg[t]-Esg))(Esg + rhog * (sg[t]-Esg))+rhog^2 phig^2 ) //Simplify),*)
(*0===(ev[sg[t+2]sg[t+1],t-1,modNRC]-( (Esg +rhog^3 * (sg[t-1]-Esg))(Esg +rhog^2 * (sg[t-1]-Esg))+rhog^3 phig^2 +rhog phig^2 ) //Simplify),*)
(*0===(ev[sg[t+3]sg[t+1],t-1,modNRC]-( (Esg + rhog^4 * (sg[t-1]-Esg))(Esg +rhog^2 * (sg[t-1]-Esg))+rhog^4 phig^2 +rhog^2 phig^2 ) //Simplify),*)
(*0===(ev[sg[t+1]pi[t+1],t,modNRC]-( (Esg +rhog * (sg[t]-Esg))(mup+rhop(pi[t]-mup)+  xip eps["pi"][t] )  ) //Simplify),*)
(*0===(ev[sg[t]pi[t],t,modNRC]-( sg[t]pi[t]  ) //Simplify),*)
(*0===(ev[sg[t-1]pi[t-1],t,modNRC]-( sg[t-1]pi[t-1]  ) //Simplify),*)
(*0===(ev[sg[t-2]pi[t-2],t,modNRC]-( sg[t-2]pi[t-2]  ) //Simplify),0===(ev[sg[t+1]pi[t+1],t+1,modNRC]-( sg[t+1]pi[t+1] ) //Simplify),*)
(*0===(ev[sg[t+1]pi[t+1],t,modNRC]-( (Esg + rhog * (sg[t]-Esg))(mup+rhop(pi[t]-mup)+  xip eps["pi"][t] )  ) //Simplify),*)
(*0===(ev[sg[t+1]pi[t+1],t-1,modNRC]-( (Esg +rhog^2 * (sg[t-1]-Esg))(mup+rhop^2 (pi[t-1]-mup)+ rhop  xip eps["pi"][t-1] )  ) //Simplify),*)
(*0===(ev[sg[t+1]pi[t+1],t-2,modNRC]-( (Esg + rhog^3 * (sg[t-2]-Esg))(mup+rhop^3 (pi[t-2]-mup)+ rhop^2  xip eps["pi"][t-2] )  ) //Simplify),0===(ev[sg[t+1]^2,t,modNRC]-( (Esg + rhog * (sg[t]-Esg))^2+phig^2 ) //Simplify),*)
(*0===(ev[sg[t]^2,t,modNRC]-(sg[t]^2 ) //Simplify),*)
(*0===(ev[sg[t-1]^2,t,modNRC]-(sg[t-1]^2 ) //Simplify),*)
(*0===(ev[sg[t-2]^2,t,modNRC]-(sg[t-2]^2 ) //Simplify),0===(ev[sg[t+1]^2,t+1,modNRC]-(sg[t+1]^2 ) //Simplify),*)
(*0===(ev[sg[t+1]^2,t,modNRC]-( (Esg + rhog * (sg[t]-Esg) )^2+ phig^2) //Simplify),*)
(*0===(ev[sg[t+1]^2,t-1,modNRC]-( (Esg + rhog^2 * (sg[t-1]-Esg) )^2+(rhog^2+1) phig^2)//Simplify),*)
(*0===(ev[sg[t+1]^2,t-2,modNRC]-( (Esg + rhog^3 * (sg[t-2]-Esg) )^2+(rhog^4+rhog^2+1) phig^2)//Simplify),*)
(*0===(ev[sg[t+1],t,modNRC]-(Esg + rhog * (sg[t]-Esg) ) //Simplify),*)
(*0===(ev[sg[t],t,modNRC]-(sg[t] ) //Simplify),*)
(*0===(ev[sg[t-1],t,modNRC]-(sg[t-1] ) //Simplify),*)
(*0===(ev[sg[t-2],t,modNRC]-(sg[t-2] ) //Simplify),0===(ev[sg[t+1],t+1,modNRC]-(sg[t+1]) //Simplify),*)
(*0===(ev[sg[t+1],t,modNRC]-(Esg + rhog  (sg[t]-Esg) ) //Simplify),*)
(*0===(ev[sg[t+1],t-1,modNRC]-(Esg + rhog^2  (sg[t-1]-Esg)  ) //Simplify),0===(ev[dc[t+1],t-1,modNRC]-(muc+rhocp rhop(pi[t-1]-mup)+rhocp xip eps["pi"][t-1] ) //Simplify),*)
(*0===(ev[dc[t],t-1,modNRC]-( muc+rhocp (pi[t-1]-mup) +  xic sg[t-2] eps["pi"][t-1]  ) //Simplify)*)
(*}*)
(*,"ConfirmResults"->confirm]; *)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*dc1=(dc[t-1]/.Normal@modNRC["exogenousEq"]);*)
(*dc2=(dc[t-2]/.Normal@modNRC["exogenousEq"]);*)
(*And@@{*)
(*dc1===(muc+rhocp (pi[t-2]-mup)+ xic sg[t-3]eps["pi"][t-2]+phic eps["dc"][t-1]  )//Simplify,*)
(*0===(ev[dc[t-1],t-1,modNRC]-(muc+rhocp (pi[t-2]-mup)+ xic sg[t-3]eps["pi"][t-2]+phic eps["dc"][t-1]  )//Simplify),*)
(*dc2===(muc+rhocp (pi[t-3]-mup)+ xic sg[t-4]eps["pi"][t-3]+phic eps["dc"][t-2]    )//Simplify,*)
(*0===(ev[dc[t-2],t-1,modNRC]-(muc+rhocp (pi[t-3]-mup)+ xic sg[t-4]eps["pi"][t-3]+phic eps["dc"][t-2]  ) //Simplify),*)
(*0===(ev[dc[t+1],t,modNRC]-(muc+rhocp (pi[t]-mup)+ xic sg[t-1]eps["pi"][t] ) //Simplify),*)
(*0===(ev[dc[t+1],t-1,modNRC]-( muc+rhocp rhop(pi[t-1]-mup) + rhocp xip eps["pi"][t-1]  ) //Simplify),*)
(*0===(ev[dc[t+1],t-2,modNRC]-( muc+rhocp rhop^2 (pi[t-2]-mup )+ rhocp rhop xip eps["pi"][t-2]  ) //Simplify),*)
(*0===(ev[eps["pi"][t+2]pi[t+1],t-1,modNRC]-(0 ) //Simplify),*)
(*0===(ev[eps["pi"][t+1]pi[t+1],t-1,modNRC]-( phip  ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t+1],t-1,modNRC]-( rhop phip+ xip ) //Simplify),*)
(*0===(ev[eps["pi"][t-1]pi[t+1],t-1,modNRC]-((mup+rhop^2 (pi[t-1]-mup)+rhop xip eps["pi"][t-1])eps["pi"][t-1]  ) //Simplify),*)
(*0===(ev[eps["pi"][t-2]pi[t+1],t-1,modNRC]-((mup+rhop^2 (pi[t-1]-mup)+rhop xip eps["pi"][t-1])eps["pi"][t-2]  ) //Simplify),0===(ev[eps["pi"][t+2]pi[t+1],t,modNRC]-(0 ) //Simplify),*)
(*0===(ev[eps["pi"][t+1]pi[t+1],t,modNRC]-( phip  ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t+1],t,modNRC]-((mup+rhop (pi[t]-mup)+xip eps["pi"][t])eps["pi"][t]  ) //Simplify),*)
(*0===(ev[eps["pi"][t-1]pi[t+1],t,modNRC]-((mup+rhop (pi[t]-mup)+xip eps["pi"][t])eps["pi"][t-1]  ) //Simplify),*)
(*0===(ev[eps["pi"][t-2]pi[t+1],t,modNRC]-((mup+rhop (pi[t]-mup)+xip eps["pi"][t])eps["pi"][t-2]  ) //Simplify),*)
(*0===(ev[eps["pi"][t+2]pi[t+1],t+1,modNRC]-(0 ) //Simplify),*)
(*0===(ev[eps["pi"][t+1]pi[t+1],t+1,modNRC]-( eps["pi"][t+1]pi[t+1]  ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t+1],t+1,modNRC]-( eps["pi"][t]pi[t+1] ) //Simplify),*)
(*0===(ev[eps["pi"][t-1]pi[t+1],t+1,modNRC]-( eps["pi"][t-1]pi[t+1]  ) //Simplify),*)
(*0===(ev[eps["pi"][t-2]pi[t+1],t+1,modNRC]-( eps["pi"][t-2]pi[t+1] ) //Simplify),0===(ev[eps["pi"][t]pi[t+2],t-2,modNRC]-( rhop( rhop phip+xip ) ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t+1],t-2,modNRC]-( rhop phip+xip  ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t],t-2,modNRC]-( phip ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t-1],t-2,modNRC]-( 0 ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t-2],t-2,modNRC]-( 0 ) //Simplify),0===(ev[eps["pi"][t]pi[t+2],t-1,modNRC]-( rhop( rhop phip+xip ) ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t+1],t-1,modNRC]-( rhop phip+xip  ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t],t-1,modNRC]-( phip ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t-1],t-1,modNRC]-( 0 ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t-2],t-1,modNRC]-( 0 ) //Simplify),0===(ev[eps["pi"][t]pi[t+2],t,modNRC]-( (mup+rhop^2 (pi[t]-mup)+ rhop xip eps["pi"][t] )eps["pi"][t] ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t+1],t,modNRC]-( (mup+rhop(pi[t]-mup)+  xip eps["pi"][t] )eps["pi"][t] ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t],t,modNRC]-( eps["pi"][t]pi[t] ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t-1],t,modNRC]-( eps["pi"][t]pi[t-1] ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t-2],t,modNRC]-( eps["pi"][t]pi[t-2] ) //Simplify),0===(ev[eps["pi"][t]pi[t+2],t+1,modNRC]-( (mup+rhop(pi[t+1]-mup)+ xip eps["pi"][t+1] )eps["pi"][t] ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t+1],t+1,modNRC]-( eps["pi"][t]pi[t+1] ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t],t+1,modNRC]-( eps["pi"][t]pi[t] ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t-1],t+1,modNRC]-( eps["pi"][t]pi[t-1] ) //Simplify),*)
(*0===(ev[eps["pi"][t]pi[t-2],t+1,modNRC]-( eps["pi"][t]pi[t-2] ) //Simplify),0===(ev[pi[t+2],t+2,modNRC]-(pi[t+2] ) //Simplify),*)
(*0===(ev[pi[t+2],t+1,modNRC]-(mup+rhop(pi[t+1]-mup)+ xip eps["pi"][t+1]  )//Simplify),*)
(*0===(ev[pi[t+2],t,modNRC]-(mup+rhop^2 (pi[t]-mup)+rhop xip eps["pi"][t] )//Simplify),*)
(*0===(ev[pi[t+2],t-1,modNRC]-(mup+rhop^3 (pi[t-1]-mup)+rhop^2 xip eps["pi"][t-1] )//Simplify),*)
(*0===(ev[pi[t+2],t-2,modNRC]-(mup+rhop^4 (pi[t-2]-mup)+rhop^3 xip eps["pi"][t-2] )//Simplify),0===(ev[pi[t+1],t,modNRC]-(mup+rhop(pi[t]-mup)+xip eps["pi"][t] ) //Simplify),*)
(*0===(ev[pi[t+1],t-1,modNRC]-(mup+rhop^2 (pi[t-1]-mup)+rhop xip eps["pi"][t-1] )//Simplify),*)
(*0===(ev[pi[t+1],t-2,modNRC]-(mup+rhop^3 (pi[t-2]-mup)+rhop^2 xip eps["pi"][t-2] )//Simplify),0===(ev[pi[t+1],t,modNRC]-(mup+rhop(pi[t]-mup)+xip eps["pi"][t] ) //Simplify),*)
(*0===(ev[dc[t+1],t,modNRC]-(muc+rhocp(pi[t]-mup)+xic sg[t-1]eps["pi"][t] )//Simplify),*)
(*0===(ev[sg[t+1],t,modNRC]-(Esg + rhog * (sg[t]-Esg))//Simplify),*)
(*0===(ev[dd[t+1,i],t,modNRC]-(mud[i]+rhodp[i](pi[t]-mup)+xid[i]sg[t-1] eps["pi"][t] )//Simplify),*)
(*0===(ev[pi[t+1]^2,t,modNRC]- ((mup+rhop(pi[t]-mup)+xip eps["pi"][t] )^2+phip^2 )//Simplify),*)
(*0===(ev[dc[t+1]^2,t,modNRC]-((muc+rhocp(pi[t]-mup)+xic sg[t-1]eps["pi"][t] )^2+phic^2)//Simplify),*)
(*0===(ev[sg[t+1]^2,t,modNRC]-((Esg + rhog * (sg[t]-Esg))^2+phig^2)//Simplify),*)
(*0===(ev[dd[t+1,i]^2,t,modNRC]-((mud[i]+rhodp[i](pi[t]-mup)+xid[i]sg[t-1] eps["pi"][t] )^2+phidc[i]^2)//Simplify),*)
(*0===(var[pi[t+1],t,modNRC]- (phip^2)//Simplify),*)
(*0===(var[dc[t+1],t,modNRC]-(phic^2)//Simplify),*)
(*0===(var[sg[t+1],t,modNRC]-(phig^2)//Simplify),*)
(*0===(var[dd[t+1,i],t,modNRC]-(phidc[i]^2)//Simplify)*)
(*}*)
(*,"ConfirmResults"->confirm]; *)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*law of iterated expectations*)*)
(*And@@{*)
(*0===(ev[pi[t+1],t-1,modNRC]- ev[ev[pi[t+1],t,modNRC],t-1,modNRC]//Simplify),*)
(*0===(ev[dc[t+1],t-1,modNRC]-ev[ev[dc[t+1],t,modNRC],t-1,modNRC]//Simplify),*)
(*0===(ev[sg[t+1],t-1,modNRC]-ev[ev[sg[t+1],t,modNRC],t-1,modNRC]//Simplify),*)
(*0===(ev[dd[t+1,i],t-1,modNRC]-ev[ev[dd[t+1,i],t,modNRC],t-1,modNRC]//Simplify),*)
(**)
(*0===(ev[pi[t+1]dc[t+1],t-1,modNRC]- ev[ev[pi[t+1]dc[t+1],t,modNRC],t-1,modNRC]//Simplify),*)
(*0===(ev[dc[t+1]sg[t+1],t-1,modNRC]-ev[ev[dc[t+1]sg[t+1],t,modNRC],t-1,modNRC]//Simplify),*)
(*0===(ev[sg[t+1]^2,t-1,modNRC]-ev[ev[sg[t+1]^2,t,modNRC],t-1,modNRC]//Simplify),*)
(*0===(ev[dd[t+2,i],t-1,modNRC]-ev[ev[dd[t+2,i],t,modNRC],t-1,modNRC]//Simplify),*)
(**)
(*(*law of iterated expectations used to compute unconditional moments*)0===ev[pi[t]eps["pi"][t+1],t-1,modNRC]=== ev[ev[pi[t]eps["pi"][t+1],t,modNRC],t-1,modNRC],*)
(*0===ev[pi[t]eps["dc"][t+1],t-1,modNRC]=== ev[ev[pi[t]eps["dc"][t+1],t,modNRC],t-1,modNRC],*)
(*0===ev[pi[t]eps["sg"][t+1],t-1,modNRC]=== ev[ev[pi[t]eps["sg"][t+1],t,modNRC],t-1,modNRC],*)
(*0===ev[sg[t]eps["pi"][t+1],t-1,modNRC]=== ev[ev[sg[t]eps["pi"][t+1],t,modNRC],t-1,modNRC],*)
(*0===ev[sg[t]eps["dc"][t+1],t-1,modNRC]=== ev[ev[sg[t]eps["dc"][t+1],t,modNRC],t-1,modNRC],*)
(*0===ev[sg[t]eps["sg"][t+1],t-1,modNRC]=== ev[ev[sg[t]eps["sg"][t+1],t,modNRC],t-1,modNRC],*)
(**)
(*0===ev[pi[t]^2 eps["pi"][t+2],t-1,modNRC]=== ev[ev[pi[t]^2 eps["pi"][t+2],t,modNRC],t-1,modNRC],*)
(*0===ev[pi[t]^2 eps["dc"][t+2],t-1,modNRC]=== ev[ev[pi[t]^2 eps["dc"][t+2],t,modNRC],t-1,modNRC],*)
(*0===ev[pi[t]^2 eps["sg"][t+2],t-1,modNRC]=== ev[ev[pi[t]^2 eps["sg"][t+2],t,modNRC],t-1,modNRC],*)
(*0===ev[sg[t]^2 eps["pi"][t+2],t-1,modNRC]=== ev[ev[sg[t]^2 eps["pi"][t+2],t,modNRC],t-1,modNRC],*)
(*0===ev[sg[t]^2 eps["dc"][t+2],t-1,modNRC]=== ev[ev[sg[t]^2 eps["dc"][t+2],t,modNRC],t-1,modNRC],*)
(*0===ev[sg[t]^2 eps["sg"][t+2],t-1,modNRC]=== ev[ev[sg[t]^2 eps["sg"][t+2],t,modNRC],t-1,modNRC],*)
(*(*law of iterated expectations for shocks squared*)*)
(*(*pi*)*)
(*ev[pi[t],t-1,modNRC]===ev[pi[t]ev[eps["pi"][t+1]^2,t,modNRC],t-1,modNRC]===ev[pi[t]eps["pi"][t+1]^2,t-1,modNRC]=== ev[ev[pi[t]eps["pi"][t+1]^2,t,modNRC],t-1,modNRC],*)
(**)
(*ev[pi[t],t-1,modNRC]===ev[pi[t]ev[eps["sg"][t+1]^2,t,modNRC],t-1,modNRC]===ev[pi[t]eps["sg"][t+1]^2,t-1,modNRC]=== ev[ev[pi[t]eps["sg"][t+1]^2,t,modNRC],t-1,modNRC],*)
(**)
(*ev[pi[t],t-1,modNRC]===ev[pi[t]ev[eps["dc"][t+1]^2,t,modNRC],t-1,modNRC]===ev[pi[t]eps["dc"][t+1]^2,t-1,modNRC]===ev[ev[pi[t]eps["dc"][t+1]^2,t,modNRC],t-1,modNRC],*)
(**)
(*(*sg*)*)
(*ev[sg[t],t-1,modNRC]===ev[sg[t]ev[eps["pi"][t+1]^2,t,modNRC],t-1,modNRC]===ev[sg[t]eps["pi"][t+1]^2,t-1,modNRC]=== ev[ev[sg[t]eps["pi"][t+1]^2,t,modNRC],t-1,modNRC],*)
(**)
(*ev[sg[t],t-1,modNRC]===ev[sg[t]ev[eps["sg"][t+1]^2,t,modNRC],t-1,modNRC]===ev[sg[t]eps["sg"][t+1]^2,t-1,modNRC]===ev[ev[sg[t]eps["sg"][t+1]^2,t,modNRC],t-1,modNRC],*)
(**)
(*ev[sg[t],t-1,modNRC]===ev[sg[t]ev[eps["dc"][t+1]^2,t,modNRC],t-1,modNRC]===ev[sg[t]eps["dc"][t+1]^2,t-1,modNRC]=== ev[ev[sg[t]eps["dc"][t+1]^2,t,modNRC],t-1,modNRC],*)
(**)
(*(*dc*)*)
(*ev[dc[t],t-1,modNRC]===ev[dc[t]ev[eps["pi"][t+1]^2,t,modNRC],t-1,modNRC]===ev[dc[t]eps["pi"][t+1]^2,t-1,modNRC]=== ev[ev[dc[t]eps["pi"][t+1]^2,t,modNRC],t-1,modNRC],*)
(**)
(*ev[dc[t],t-1,modNRC]===ev[dc[t]ev[eps["sg"][t+1]^2,t,modNRC],t-1,modNRC]===ev[dc[t]eps["sg"][t+1]^2,t-1,modNRC]=== ev[ev[dc[t]eps["sg"][t+1]^2,t,modNRC],t-1,modNRC],*)
(**)
(*ev[dc[t],t-1,modNRC]===ev[dc[t]ev[eps["dc"][t+1]^2,t,modNRC],t-1,modNRC]===ev[dc[t]eps["dc"][t+1]^2,t-1,modNRC]=== ev[ev[dc[t]eps["dc"][t+1]^2,t,modNRC],t-1,modNRC],*)
(**)
(*(*dd*)*)
(*ev[dd[t,i],t-1,modNRC]===ev[dd[t,i]ev[eps["pi"][t+1]^2,t,modNRC],t-1,modNRC]===ev[dd[t,i]eps["pi"][t+1]^2,t-1,modNRC]=== ev[ev[dd[t,i]eps["pi"][t+1]^2,t,modNRC],t-1,modNRC],*)
(**)
(*ev[dd[t,i],t-1,modNRC]===ev[dd[t,i]ev[eps["sg"][t+1]^2,t,modNRC],t-1,modNRC]===ev[dd[t,i]eps["sg"][t+1]^2,t-1,modNRC]=== ev[ev[dd[t,i]eps["sg"][t+1]^2,t,modNRC],t-1,modNRC],*)
(**)
(*ev[dd[t,i],t-1,modNRC]===ev[dd[t,i]ev[eps["dc"][t+1]^2,t,modNRC],t-1,modNRC]===ev[dd[t,i]eps["dc"][t+1]^2,t-1,modNRC]=== ev[ev[dd[t,i]eps["dc"][t+1]^2,t,modNRC],t-1,modNRC]*)
(*}*)
(*,"ConfirmResults"->confirm]; *)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*(*works in different contexts for variable symbol*)*)
(*ev[pi[t+1],t,modNRC]===ev[foo`pi[t+1],t,modNRC]===(ev[foo`pi[foo`t+1],foo`t,modNRC]/.foo`t->t),*)
(**)
(*(*differentiates contexts for time index*)*)
(*ev[pi[foo`t+1],t,modNRC]===FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[1+foo`t],*)
(*ev[pi[t+1],foo`t,modNRC]===FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[1+t],*)
(*ev[foo`pi[foo`t+1],t,modNRC]===FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[1+foo`t],*)
(*ev[foo`pi[t+1],foo`t,modNRC]===FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[1+t],*)
(*ev[foo`pi[bar`t+1],t,modNRC]===FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[1+bar`t],*)
(*ev[foo`pi[t+1],bar`t,modNRC]===FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[1+t],*)
(*ev[foo`pi[bar`t+1],goo`t,modNRC]===FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[1+bar`t]*)
(*} *)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*(*basic functionality of lagStateVarst*)*)
(*lagStateVarst[pi[t],t-1,modNRC]===(FernandoDuarte`LongRunRisk`Model`Parameters`mup+FernandoDuarte`LongRunRisk`Model`Parameters`rhop (-FernandoDuarte`LongRunRisk`Model`Parameters`mup+FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[-1+t])+FernandoDuarte`LongRunRisk`Model`Parameters`xip FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][-1+t]+FernandoDuarte`LongRunRisk`Model`Parameters`phip FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t]),*)
(**)
(*lagStateVarst[pi[t+1],t,modNRC]===(lagStateVarst[pi[t],t-1,modNRC]/.t->t+1),*)
(**)
(*lagStateVarst[pi[t+1],t-1,modNRC]===(FernandoDuarte`LongRunRisk`Model`Parameters`mup+FernandoDuarte`LongRunRisk`Model`Parameters`xip FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t]+FernandoDuarte`LongRunRisk`Model`Parameters`rhop (FernandoDuarte`LongRunRisk`Model`Parameters`rhop (-FernandoDuarte`LongRunRisk`Model`Parameters`mup+FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[-1+t])+FernandoDuarte`LongRunRisk`Model`Parameters`xip FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][-1+t]+FernandoDuarte`LongRunRisk`Model`Parameters`phip FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t])+FernandoDuarte`LongRunRisk`Model`Parameters`phip FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][1+t]),*)
(**)
(*lagStateVarst[pi[t]eps["pi"][t+2],t,modNRC]===(FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[t] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][2+t]),*)
(**)
(*lagStateVarst[pi[t]eps["pi"][t],t-1,modNRC]===(FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t] (FernandoDuarte`LongRunRisk`Model`Parameters`mup+FernandoDuarte`LongRunRisk`Model`Parameters`rhop (-FernandoDuarte`LongRunRisk`Model`Parameters`mup+FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[-1+t])+FernandoDuarte`LongRunRisk`Model`Parameters`xip FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][-1+t]+FernandoDuarte`LongRunRisk`Model`Parameters`phip FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t])),*)
(**)
(*lagStateVarst[delta,t-1,modNRC]===(FernandoDuarte`LongRunRisk`Model`Parameters`delta),lagStateVarst[A[0],t-1,modNRC]===FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`A[0] ,lagStateVarst[R[-1+m][0],t-1,modNRC]===FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`R[-1+m][0],*)
(**)
(*(*does not evaluate with XXeq variables*)*)
(*lagStateVarst[pieq[t,m],t+1,modNRC]===pieq[t,m],*)
(*lagStateVarst[wceq[t],t+1,modNRC]===wceq[t],*)
(**)
(*(*lagStateVarst is listable*)*)
(*lagStateVarst[{pi[t],sg[t],dc[t]},t-1,modNRC]==={lagStateVarst[pi[t],t-1,modNRC],lagStateVarst[sg[t],t-1,modNRC],lagStateVarst[dc[t],t,modNRC]},*)
(**)
(*(*contexts in lagStateVarst*)*)
(*(*contexts of expr*)*)
(*lagStateVarst[foo`pi[t],t-1,modNRC]===lagStateVarst[pi[t],t-1,modNRC],*)
(*lagStateVarst[foo`pi[t]pi[t],t-1,modNRC]===lagStateVarst[foo`pi[t]^2,t-1,modNRC]===lagStateVarst[pi[t]^2,t-1,modNRC],*)
(*lagStateVarst[foo`pi[t]eps["pi"][t]bar`delta,t-1,modNRC]===lagStateVarst[pi[t]foo`eps["pi"][t]delta,t-1,modNRC],*)
(**)
(*(*contexts of conditionalTime*)*)
(*lagStateVarst[pi[foo`t],t-1,modNRC]===FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[foo`t],*)
(*lagStateVarst[pi[t],t-1,modNRC]===(lagStateVarst[pi[foo`t],foo`t-1,modNRC]/.foo`t->t),*)
(*ExpandAll[lagStateVarst[pi[foo`t]pi[t],foo`t-1,modNRC]]===ExpandAll[FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[t]lagStateVarst[pi[foo`t],foo`t-1,modNRC]],*)
(*lagStateVarst[pi[foo`t-1]pi[t],foo`t-1,modNRC]===(FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[-1+foo`t] FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[t])*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*remove context alias*)*)
(*(*$ContextAliases["ce`"]=.;*)*)
(*True*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*End[];*)


(* ::Input:: *)
(*addBeginEnd[testFilePath,testContext];*)
(*{*)
(*tr[Evaluate@name]["TestReport"] ,*)
(*tr[Evaluate@name]["ActualOutput"] ,*)
(*tr[Evaluate@name]["ExpectedOutput"] ,*)
(*tr[Evaluate@name]["OutputTrueQ"]*)
(*}=runTests[testFilePath];*)
(*(*tableActualVsExpeected[testName_String];*)*)
(*cleanUp[];*)


(* ::Section:: *)
(*ComputationalEngine`ComputeUnconditionalExpectations`*)


(* ::Input:: *)
(*name = First@NotebookRead[PreviousCell[CellStyle -> "Section"]];*)
(*makeDefinitions[name];*)


(* ::Input:: *)
(*Begin[Evaluate@testContext];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*longTest = False; (*fast and partial coverage (False) or slow and full coverage (True)*)*)
(*True*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Needs["PacletizedResourceFunctions`"];*)
(*True*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*With[{context=context},*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Needs@context;*)
(*(*$ContextAliases["ce`"]="FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeUnconditionalExpectations`Private`";*)*)
(*$ContextPath = DeleteDuplicates@Prepend[$ContextPath,"FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeUnconditionalExpectations`Private`"];*)
(**)
(*Needs["FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeConditionalExpectations`"];*)
(*$ContextPath = DeleteDuplicates@Prepend[$ContextPath,"FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeConditionalExpectations`Private`"];*)
(**)
(*True*)
(*,"ConfirmResults"->confirm];*)
(*];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*MemberQ[$ContextPath,"FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeUnconditionalExpectations`"]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*should be true if uncondE can be found*)*)
(*Not[Names["*uncondE"]==={}]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Get@Get[FileNameJoin[{"FernandoDuarte/LongRunRisk","Models.wl"}]];*)
(*msp=FernandoDuarte`LongRunRisk`Models;*)
(*modBY=msp["BY"];*)
(*modNRC=msp["NRC"];*)
(**)
(*(*createSystem=FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeUnconditionalExpectations`Private`createSystem;*)
(*evNoEpsStateVarsProduct=FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeUnconditionalExpectations`Private`evNoEpsStateVarsProduct;*)
(*uncondEStep=FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeUnconditionalExpectations`Private`uncondEStep;*)*)
(**)
(*True*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*If[longTest,*)
(*(*system of equations for unconditional moments of state variables*)*)
(*{nameRules1,system1,unknowns1}=createSystem[1,modNRC];*)
(*{nameRules2,system2,unknowns2}=createSystem[2,modNRC];*)
(*{nameRules3,system3,unknowns3}=createSystem[3,modNRC];*)
(*{nameRules4,system4,unknowns4}=createSystem[4,modNRC];*)
(**)
(*sol1=Flatten@Solve[system1,unknowns1];*)
(*sol2=Flatten@Solve[system2,unknowns2];*)
(*sol3=Flatten@Solve[system3,unknowns3];*)
(*sol4=Flatten@Solve[system4,unknowns4];*)
(**)
(*And@@{*)
(*(*system is well-formed*)*)
(*And@@{*)
(*Not[nameRules1===$Failed],*)
(*Not[system1===$Failed],*)
(*Not[unknowns1===$Failed]*)
(*},*)
(**)
(*(*system is well-formed*)*)
(*And@@{*)
(*Not[nameRules2===$Failed],*)
(*Not[system2===$Failed],*)
(*Not[unknowns2===$Failed]*)
(*},*)
(**)
(*(*system is well-formed*)*)
(*And@@{*)
(*Not[nameRules3===$Failed],*)
(*Not[system3===$Failed],*)
(*Not[unknowns3===$Failed]*)
(*},*)
(**)
(*(*system is well-formed*)*)
(*And@@{*)
(*Not[nameRules4===$Failed],*)
(*Not[system4===$Failed],*)
(*Not[unknowns4===$Failed]*)
(*},*)
(**)
(*(*there is a solution*)*)
(*And@@{*)
(*Not[sol1==={}],*)
(*Not[sol2==={}],*)
(*Not[sol3==={}],*)
(*Not[sol4==={}]*)
(*},*)
(**)
(*(*solutions are the same for same moments*)*)
(*And@@{*)
(*MatchQ@@(Intersection[unknowns1,unknowns3]/.{sol1,sol3}),*)
(*MatchQ@@(Intersection[unknowns2,unknowns3]/.{sol2,sol3}),*)
(*MatchQ@@(Intersection[unknowns1,unknowns4]/.{sol1,sol4}),*)
(*MatchQ@@(Intersection[unknowns2,unknowns4]/.{sol2,sol4}),*)
(*MatchQ@@(Intersection[unknowns3,unknowns4]/.{sol3,sol4})*)
(*}*)
(*},*)
(*True*)
(*]*)
(**)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*If[longTest,*)
(*(*check with moments computed by hand*)*)
(**)
(*And@@{*)
(*(FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeUnconditionalExpectations`Private`pi1/.sol1)===FernandoDuarte`LongRunRisk`Model`Parameters`mup,*)
(*(FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeUnconditionalExpectations`Private`sg1/.sol1)===FernandoDuarte`LongRunRisk`Model`Parameters`Esg,*)
(*FullSimplify@ExpandAll[FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeUnconditionalExpectations`Private`pi2/.sol2]===FullSimplify@ExpandAll[FernandoDuarte`LongRunRisk`Model`Parameters`mup^2+(FernandoDuarte`LongRunRisk`Model`Parameters`xip^2+2 FernandoDuarte`LongRunRisk`Model`Parameters`rhop FernandoDuarte`LongRunRisk`Model`Parameters`xip FernandoDuarte`LongRunRisk`Model`Parameters`phip + FernandoDuarte`LongRunRisk`Model`Parameters`phip^2)/(1-FernandoDuarte`LongRunRisk`Model`Parameters`rhop^2)],*)
(*Simplify[FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeUnconditionalExpectations`Private`sg2/.sol2]===Simplify[FernandoDuarte`LongRunRisk`Model`Parameters`Esg^2+FernandoDuarte`LongRunRisk`Model`Parameters`phig^2/(1-FernandoDuarte`LongRunRisk`Model`Parameters`rhog^2)],*)
(*Simplify[FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeUnconditionalExpectations`Private`pi1sg1/.sol2]===Simplify[FernandoDuarte`LongRunRisk`Model`Parameters`Esg*FernandoDuarte`LongRunRisk`Model`Parameters`mup]*)
(*},*)
(*True*)
(*]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*check with moments computed by hand*)*)
(*And@@{*)
(*uncondE[pi[t],modNRC]===FernandoDuarte`LongRunRisk`Model`Parameters`mup,*)
(**)
(*uncondE[sg[t],modNRC]===FernandoDuarte`LongRunRisk`Model`Parameters`Esg,*)
(**)
(*FullSimplify@ExpandAll[uncondE[pi[t]^2,modNRC]]===FullSimplify@ExpandAll[FernandoDuarte`LongRunRisk`Model`Parameters`mup^2+(FernandoDuarte`LongRunRisk`Model`Parameters`xip^2+2 FernandoDuarte`LongRunRisk`Model`Parameters`rhop FernandoDuarte`LongRunRisk`Model`Parameters`xip FernandoDuarte`LongRunRisk`Model`Parameters`phip + FernandoDuarte`LongRunRisk`Model`Parameters`phip^2)/(1-FernandoDuarte`LongRunRisk`Model`Parameters`rhop^2)],*)
(**)
(*Simplify[uncondE[sg[t]^2,modNRC]]===Simplify[FernandoDuarte`LongRunRisk`Model`Parameters`Esg^2+FernandoDuarte`LongRunRisk`Model`Parameters`phig^2/(1-FernandoDuarte`LongRunRisk`Model`Parameters`rhog^2)],*)
(**)
(*Simplify[uncondE[pi[t]sg[t],modNRC]]===Simplify[FernandoDuarte`LongRunRisk`Model`Parameters`Esg*FernandoDuarte`LongRunRisk`Model`Parameters`mup]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*If[longTest,*)
(*(*moments can be evaluated numerically using parameters values only*)*)
(*And@@{*)
(*And@@(NumberQ/@(Values@sol1//.modNRC["parameters"])),*)
(*And@@(NumberQ/@(Values@sol2//.modNRC["parameters"])),*)
(*And@@(NumberQ/@(Values@sol3//.modNRC["parameters"])),*)
(*And@@(NumberQ/@(Values@sol4//.modNRC["parameters"]))*)
(*}*)
(*,*)
(*True*)
(*]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*evNoEpsStateVarsProduct*)*)
(*stateVarsNoEps={sg,pi};*)
(*model=modNRC;*)
(**)
(*(*basic use*)*)
(*And@@{*)
(*evNoEpsStateVarsProduct[pi[t]eps["pi"][t-1],model,stateVarsNoEps]===evNoEpsStateVarsProduct[eps["pi"][t-1]pi[t],model,stateVarsNoEps],*)
(**)
(*evNoEpsStateVarsProduct[pi[t],model,stateVarsNoEps]===FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[t],*)
(**)
(*evNoEpsStateVarsProduct[pi[t]sg[t],model,stateVarsNoEps]===FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[t] FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`sg[t],*)
(**)
(*ExpandAll[evNoEpsStateVarsProduct[pi[t-1]sg[t],model,stateVarsNoEps]]===ExpandAll[(FernandoDuarte`LongRunRisk`Model`Parameters`Esg FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[-1+t]-FernandoDuarte`LongRunRisk`Model`Parameters`Esg FernandoDuarte`LongRunRisk`Model`Parameters`rhog FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[-1+t]+FernandoDuarte`LongRunRisk`Model`Parameters`rhog FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[-1+t] FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`sg[-1+t]+FernandoDuarte`LongRunRisk`Model`Parameters`phig FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[-1+t] FernandoDuarte`LongRunRisk`Model`Shocks`eps["sg"][t])],*)
(**)
(*ExpandAll[evNoEpsStateVarsProduct[pi[t]eps["pi"][t],model,stateVarsNoEps]]===ExpandAll[FernandoDuarte`LongRunRisk`Model`Parameters`mup FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t]-FernandoDuarte`LongRunRisk`Model`Parameters`mup FernandoDuarte`LongRunRisk`Model`Parameters`rhop FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t]+FernandoDuarte`LongRunRisk`Model`Parameters`rhop FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[-1+t] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t]+FernandoDuarte`LongRunRisk`Model`Parameters`xip FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][-1+t] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t]+FernandoDuarte`LongRunRisk`Model`Parameters`phip FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t]^2],*)
(**)
(*evNoEpsStateVarsProduct[pi[t]eps["pi"][t+1],model,stateVarsNoEps]===(FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[t] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][1+t]),*)
(**)
(*ExpandAll[evNoEpsStateVarsProduct[eps["pi"][t]dd[t,i],model,stateVarsNoEps]]===ExpandAll[(FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`dd[t,i] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t])],*)
(**)
(*ExpandAll[evNoEpsStateVarsProduct[eps["pi"][t]dd[t,i],model,Append[stateVarsNoEps,dd]]]===ExpandAll[*)
(*FernandoDuarte`LongRunRisk`Model`Parameters`mud[i] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t]-FernandoDuarte`LongRunRisk`Model`Parameters`mup FernandoDuarte`LongRunRisk`Model`Parameters`rhodp[i] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t]+FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[-1+t] FernandoDuarte`LongRunRisk`Model`Parameters`rhodp[i] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t]+FernandoDuarte`LongRunRisk`Model`Parameters`phidc[i] FernandoDuarte`LongRunRisk`Model`Shocks`eps["dc"][t] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t]+FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`sg[-2+t] FernandoDuarte`LongRunRisk`Model`Parameters`xid[i] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][-1+t] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t]*)
(*],*)
(**)
(*evNoEpsStateVarsProduct[pi[t]eps["pi"][t-1],model,stateVarsNoEps]===evNoEpsStateVarsProduct[eps["pi"][t-1]pi[t],model,stateVarsNoEps],*)
(**)
(*evNoEpsStateVarsProduct[pi[t]sg[t-1],model,stateVarsNoEps]===evNoEpsStateVarsProduct[sg[t-1]pi[t],model,stateVarsNoEps]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*context for shocks is "FernandoDuarte`LongRunRisk`Model`Shocks`"*)*)
(*And@@{*)
(*And@@(MatchQ[#,"FernandoDuarte`LongRunRisk`Model`Shocks`"]&/@(DeleteDuplicates@Cases[evNoEpsStateVarsProduct[pi[t-1]dd[t,i]eps["pi"][t-1],model,Append[stateVarsNoEps,dd]],x_Symbol?(MatchQ[SymbolName[#],"eps"]&)[__][__,___]:>Context@x,Infinity])),*)
(**)
(*And@@(MatchQ[#,"FernandoDuarte`LongRunRisk`Model`Shocks`"]&/@(DeleteDuplicates@Cases[evNoEpsStateVarsProduct[pi[t-1]dd[t,i]eps["pi"][t]eps["pi"][t-1],model,Append[stateVarsNoEps,dd]],x_Symbol?(MatchQ[SymbolName[#],"eps"]&)[__][__,___]:>Context@x,Infinity])),*)
(**)
(*And@@(MatchQ[#,"FernandoDuarte`LongRunRisk`Model`Shocks`"]&/@(DeleteDuplicates@Cases[evNoEpsStateVarsProduct[pi[t-1]sg[t]dd[t,i]eps["pi"][t-1],model,Append[stateVarsNoEps,dd]],x_Symbol?(MatchQ[SymbolName[#],"eps"]&)[__][__,___]:>Context@x,Infinity]))*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*check if variables lagged to the right time period*)*)
(*And@@{*)
(*{}===Cases[evNoEpsStateVarsProduct[pi[t]sg[t-1],model,stateVarsNoEps],_Symbol?(MatchQ[SymbolName[#],"pi"]&)[t],Infinity],*)
(*Not[{}===Cases[evNoEpsStateVarsProduct[pi[t]sg[t-1],model,stateVarsNoEps],_Symbol?(MatchQ[SymbolName[#],"sg"]&)[t-1],Infinity]],*)
(*{}===Cases[evNoEpsStateVarsProduct[pi[t]sg[t-1]+pi[t-1]sg[t],model,stateVarsNoEps],_Symbol?(MatchQ[SymbolName[#],"pi"]&)[t],Infinity],*)
(*{}===Cases[evNoEpsStateVarsProduct[pi[t]sg[t-1]+pi[t-1]sg[t],model,stateVarsNoEps],_Symbol?(MatchQ[SymbolName[#],"sg"]&)[t],Infinity],*)
(*Not[{}===Cases[evNoEpsStateVarsProduct[pi[t]sg[t-1]+pi[t-1]sg[t],model,stateVarsNoEps],_Symbol?(MatchQ[SymbolName[#],"pi"]&)[t-1],Infinity]],*)
(*Not[{}===Cases[evNoEpsStateVarsProduct[pi[t]sg[t-1]+pi[t-1]sg[t],model,stateVarsNoEps],_Symbol?(MatchQ[SymbolName[#],"sg"]&)[t-1],Infinity]]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*use variables indexed by time that are not lagged*)*)
(*And@@{*)
(*evNoEpsStateVarsProduct[pi[t]foo[t-1],model,stateVarsNoEps]===FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[t]foo[t-1],*)
(*(ExpandAll@evNoEpsStateVarsProduct[eps["pi"][t+1]eps["pi"][t]pi[t],model,stateVarsNoEps])===(ExpandAll@(FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t+1]*evNoEpsStateVarsProduct[eps["pi"][t]pi[t],model,stateVarsNoEps]))*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*add irrelevant variables to lag*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*evNoEpsStateVarsProduct[pi[t]eps["pi"][t-1],model,Append[stateVarsNoEps,myVariable]]===evNoEpsStateVarsProduct[eps["pi"][t-1]pi[t],model,Append[stateVarsNoEps,dd]],*)
(**)
(*evNoEpsStateVarsProduct[pi[t],model,Append[stateVarsNoEps,irrelevantVar]]===FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[t],*)
(**)
(*evNoEpsStateVarsProduct[anotherIrrelevantVar pi[t]sg[t],model,Append[stateVarsNoEps,anotherIrrelevantVar]]===anotherIrrelevantVar*FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[t] FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`sg[t]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*lag dd*)*)
(*And@@{*)
(*FreeQ[evNoEpsStateVarsProduct[pi[t-1]dd[t,i],model,Append[stateVarsNoEps,dd]],_Symbol?(MatchQ[SymbolName[#],"dd"]&)[t,i]],*)
(*FreeQ[evNoEpsStateVarsProduct[pi[t]dd[t-1,i],model,Append[stateVarsNoEps,dd]],_Symbol?(MatchQ[SymbolName[#],"pi"]&)[t]],*)
(*FreeQ[evNoEpsStateVarsProduct[pi[t-1]dd[t,i]eps["pi"][t-1],model,Append[stateVarsNoEps,dd]],_Symbol?(MatchQ[SymbolName[#],"dd"]&)[t-1,i]],*)
(*Not@FreeQ[evNoEpsStateVarsProduct[pi[t-1]dd[t,i]eps["pi"][t-1],model,Append[stateVarsNoEps,dd]],_Symbol?(MatchQ[SymbolName[#],"eps"]&)["pi"][t-1]],*)
(*FreeQ[evNoEpsStateVarsProduct[pi[t]dd[t-1,i]eps["pi"][t-1],model,Append[stateVarsNoEps,dd]],_Symbol?(MatchQ[SymbolName[#],"pi"]&)[t,i]],*)
(**)
(*(*lag dd and expression has eps["dd"]*)*)
(*FreeQ[evNoEpsStateVarsProduct[pi[t-1]dd[t,i]eps["dd"][t-1,i],model,Append[stateVarsNoEps,dd]],_Symbol?(MatchQ[SymbolName[#],"dd"]&)[t-1,i]],*)
(*Not@FreeQ[evNoEpsStateVarsProduct[pi[t-1]dd[t,i]eps["dd"][t-1,i],model,Append[stateVarsNoEps,dd]],_Symbol?(MatchQ[SymbolName[#],"eps"]&)["dd"][t-1,i]],*)
(*FreeQ[evNoEpsStateVarsProduct[pi[t]dd[t-1,i]eps["dd"][t-1,i],model,Append[stateVarsNoEps,dd]],_Symbol?(MatchQ[SymbolName[#],"pi"]&)[t]],*)
(*Not@FreeQ[evNoEpsStateVarsProduct[pi[t]dd[t-1,i]eps["dd"][t-1,i],model,Append[stateVarsNoEps,dd]],_Symbol?(MatchQ[SymbolName[#],"pi"]&)[_]],*)
(*FreeQ[uncondEStep[dc[t-1]sg[t],modNRC],_Symbol?(MatchQ[SymbolName[#],"dc"]&),Infinity],*)
(*FreeQ[uncondEStep[dc[t-1]sg[t],modNRC],_Symbol?(MatchQ[SymbolName[#],"pi"]&)[t],Infinity]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*wc,pd ratios*)*)
(*And@@{*)
(*evNoEpsStateVarsProduct[wc[t]eps["pi"][t-1],model,stateVarsNoEps]===FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`wc[t] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][-1+t],*)
(**)
(*Coefficient[evNoEpsStateVarsProduct[wc[t]eps["pi"][t],model,{wc}],FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[t-1]]===FernandoDuarte`LongRunRisk`Model`Parameters`rhop FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`A[1] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t],*)
(**)
(*DeleteDuplicates@Cases[evNoEpsStateVarsProduct[A[0]wc[t]eps["pi"][t-1],model,stateVarsNoEps],x_Symbol?(MatchQ[SymbolName[#],"A"]&)[_]:>Context@x,Infinity]==={"FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`"},*)
(**)
(*DeleteDuplicates@Cases[evNoEpsStateVarsProduct[A[0]wc[t]eps["pi"][t-1],model,{wc}],x_Symbol?(MatchQ[SymbolName[#],"A"]&)[_]:>Context@x,Infinity]==={"FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`"},*)
(**)
(*evNoEpsStateVarsProduct[pd[t,i]eps["pi"][t-1],model,stateVarsNoEps]===FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`pd[t,i] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][-1+t],*)
(**)
(*Coefficient[evNoEpsStateVarsProduct[pd[t,i]eps["pi"][t],model,{pd}],FernandoDuarte`LongRunRisk`Model`ExogenousEq`Private`pi[t-1]]===FernandoDuarte`LongRunRisk`Model`Parameters`rhop FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`B[i][1] FernandoDuarte`LongRunRisk`Model`Shocks`eps["pi"][t],*)
(**)
(*DeleteDuplicates@Cases[evNoEpsStateVarsProduct[A[0]B[i][1] pd[t,i]eps["pi"][t-1],model,stateVarsNoEps],x_Symbol?(MatchQ[SymbolName[#],"A"]&)[_]:>Context@x,Infinity]==={"FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`"},*)
(**)
(*DeleteDuplicates@Cases[evNoEpsStateVarsProduct[A[0]B[i][1] pd[t,i]eps["pi"][t-1],model,stateVarsNoEps],x_Symbol?(MatchQ[SymbolName[#],"B"]&)[_][_]:>Context@x,Infinity]==={"FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`"},*)
(**)
(*DeleteDuplicates@Cases[evNoEpsStateVarsProduct[A[0]B[i][1] pd[t,i]eps["pi"][t-1],model,{pd}],x_Symbol?(MatchQ[SymbolName[#],"A"]&)[_]:>Context@x,Infinity]==={"FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`"},*)
(**)
(*DeleteDuplicates@Cases[evNoEpsStateVarsProduct[A[0]B[i][1] pd[t,i]eps["pi"][t-1],model,{pd}],x_Symbol?(MatchQ[SymbolName[#],"B"]&)[_][_]:>Context@x,Infinity]==={"FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`"}*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*If[longTest,*)
(*(*unconditional moments*)*)
(*And@@{*)
(*Simplify[uncondE[wc[t],modNRC]]===FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`A[0],*)
(*Simplify[uncondE[wc[t],modBY]]===FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`A[0],*)
(**)
(*0===Simplify[(uncondE[pi[t]^3,modNRC]uncondE[sg[t],modNRC]-uncondE[pi[t]^3 sg[t],modNRC]) ],*)
(**)
(*0===Simplify[uncondE[pi[t]^3 sg[t],modNRC]-FernandoDuarte`LongRunRisk`Model`Parameters`Esg*FernandoDuarte`LongRunRisk`Model`Parameters`mup**)
(* (FernandoDuarte`LongRunRisk`Model`Parameters`mup^2 - *)
(*(3*(FernandoDuarte`LongRunRisk`Model`Parameters`phip^2 +  2*FernandoDuarte`LongRunRisk`Model`Parameters`phip*  FernandoDuarte`LongRunRisk`Model`Parameters`rhop*FernandoDuarte`LongRunRisk`Model`Parameters`xip +  FernandoDuarte`LongRunRisk`Model`Parameters`xip^2))/(-1 + FernandoDuarte`LongRunRisk`Model`Parameters`rhop^2)) ],*)
(**)
(*Simplify@uncondE[dc[t],modNRC]===muc,*)
(**)
(*FullSimplify@Expand@uncondE[dc[t]^2,modNRC]===FullSimplify@Expand@(muc^2+phic^2+2 Esg phip rhocp xic+xic^2 (Esg^2+phig^2/(1-rhog^2)) +(rhocp^2 (phip^2+2 phip rhop xip+xip^2))/(1-rhop^2)),*)
(**)
(*FullSimplify@Expand@uncondE[pi[t]dc[t],modNRC]===FullSimplify@Expand@(muc mup+rhocp xip phip+xic rhop phip Esg+xic xip Esg+((rhocp rhop) (xip^2+2 rhop xip phip+phip^2))/(1-rhop^2)),*)
(**)
(*FullSimplify@Expand@uncondE[sg[t]dc[t],modNRC]===FullSimplify@Expand@(muc Esg),*)
(**)
(*FullSimplify@Expand@uncondE[sg[t]sg[t+1],modNRC]===FullSimplify@Expand@(Esg^2+rhog/(1-rhog^2) phig^2 ),*)
(*FullSimplify@Expand@uncondE[sg[t]sg[t-1],modNRC]===FullSimplify@Expand@(Esg^2+rhog/(1-rhog^2) phig^2),*)
(**)
(*FullSimplify@Expand@uncondE[pi[t]pi[t+1],modNRC]===FullSimplify@Expand@(mup^2+phip xip+(rhop (phip^2+2rhop xip phip+xip^2))/(1-rhop^2)),*)
(*FullSimplify@Expand@uncondE[pi[t]pi[t-1],modNRC]===FullSimplify@Expand@(mup^2+phip xip+(rhop (phip^2+2rhop xip phip+xip^2))/(1-rhop^2)),*)
(**)
(**)
(*FullSimplify@Expand@uncondE[pi[t]sg[t+1],modNRC]===FullSimplify@Expand@(Esg mup),*)
(*FullSimplify@Expand@uncondE[pi[t-1]dc[t],modNRC]===FullSimplify@Expand@(muc mup +Esg phip  xic+(rhocp (phip^2 + 2 phip rhop  xip+ xip^2))/(1-rhop^2))*)
(*},*)
(*And@@{*)
(*Simplify[uncondE[wc[t],modNRC]]===FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`A[0],*)
(*Simplify[uncondE[wc[t],modBY]]===FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`A[0]*)
(*}*)
(*]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*End[];*)


(* ::Input:: *)
(*addBeginEnd[testFilePath,testContext];*)
(*{*)
(*tr[Evaluate@name]["TestReport"] ,*)
(*tr[Evaluate@name]["ActualOutput"] ,*)
(*tr[Evaluate@name]["ExpectedOutput"] ,*)
(*tr[Evaluate@name]["OutputTrueQ"]*)
(*}=runTests[testFilePath];*)
(*(*tableActualVsExpeected[testName_String];*)*)
(*cleanUp[];*)


(* ::Section:: *)
(*ComputationalEngine`CreateEulerEq`*)


(* ::Input:: *)
(*name = First@NotebookRead[PreviousCell[CellStyle -> "Section"]];*)
(*makeDefinitions[name];*)


(* ::Input:: *)
(*Begin[Evaluate@testContext];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*longTest = False; (*fast and partial coverage (False) or slow and full coverage (True)*)*)
(*True*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Get@Get[FileNameJoin[{"FernandoDuarte/LongRunRisk","Models.wl"}]] ;*)
(*msp=FernandoDuarte`LongRunRisk`Models;*)
(*modBY=msp["BY"];*)
(*modNRC=msp["NRC"];*)
(*modDES=msp["DES"];*)
(*mods={modBY,modNRC,modDES};*)
(*True*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*With[{context=context},*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Needs@context;*)
(*eulereq=FernandoDuarte`LongRunRisk`ComputationalEngine`CreateEulerEq`eulereq;*)
(*nomeulereq=FernandoDuarte`LongRunRisk`ComputationalEngine`CreateEulerEq`nomeulereq;*)
(*findEulerEqConstants=FernandoDuarte`LongRunRisk`ComputationalEngine`CreateEulerEq`findEulerEqConstants;*)
(**)
(*(*define functions and variables needed for tests below*)*)
(*ee[model_]:={eulereq[retc[t+1],t,model],eulereq[ret[t+1,j],t,model],eulereq[bondret[t+1,m],t,model],nomeulereq[nombondret[t+1,m],t,model]};*)
(*eeAll=ee/@mods;*)
(*	*)
(*coeffWc[model_]:=Table[FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefwc[i],{i,Length[model["stateVars"][t]]}];*)
(*coeffPd[model_]:=Table[FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefpd[i],{i,Length[model["stateVars"][t]]}];*)
(*coeffBond[model_]:=Table[FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefb[i],{i,Length[model["stateVars"][t]]}];*)
(*coeffNomBond[model_]:=Table[FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefnb[i],{i,Length[model["stateVars"][t]]}];*)
(**)
(*coeffWcAll=coeffWc/@mods;*)
(*coeffPdAll=coeffPd/@mods;*)
(*coeffBondAll=coeffBond/@mods;*)
(*coeffNomBondAll=coeffNomBond/@mods;*)
(*True*)
(*,"ConfirmResults"->confirm];*)
(*];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*should be true if uncondE can be found*)*)
(*	Not[Names["*eulereq"]==={}]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(**test eulereq, nomeulereq**)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*euler eq linear in state variables*)*)
(*And@@( *)
(*Flatten@{*)
(*(Max@Keys@CoefficientRules[#,DeleteDuplicates@Cases[modBY["stateVars"][t],_Symbol[t]^p_.,Infinity]]==1)&/@ee[modBY],*)
(*(Max@Keys@CoefficientRules[#,DeleteDuplicates@Cases[modNRC["stateVars"][t],_Symbol[t]^p_.,Infinity]]==1)&/@ee[modNRC],*)
(*(Max@Keys@CoefficientRules[#,DeleteDuplicates@Cases[modDES["stateVars"][t],_Symbol[t]^p_.,Infinity]]==1)&/@ee[modDES]*)
(*}*)
(*)*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*euler eq has all wc coefficients*)*)
(*And@@Flatten@{*)
(*Table[(Not@FreeQ[eeAll[[;;,1]][[n]],#]&/@coeffWcAll[[n]]),{n,1,Length[mods]}],*)
(*Table[(Not@FreeQ[eeAll[[;;,2]][[n]],#]&/@coeffPdAll[[n]]),{n,1,Length[mods]}],*)
(*Table[(Not@FreeQ[eeAll[[;;,3]][[n]],#]&/@coeffBondAll[[n]]),{n,1,Length[mods]}],*)
(*Table[(Not@FreeQ[eeAll[[;;,4]][[n]],#]&/@coeffNomBondAll[[n]]),{n,1,Length[mods]}]*)
(*}*)
(**)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(**test findEulerEqConstants**)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*If[longTest,*)
(*(*number of equations for the coefficients equals number of state variables plus 1 (for the term that does not multiply any state var)*)*)
(*And@@Flatten@{*)
(*(Count[Cases[First@findEulerEqConstants[retc[t],#],0==x__ :> True],True]===Length[#["stateVars"][t]]+1)&/@mods,*)
(*(Count[Cases[First@findEulerEqConstants[ret[t,j],#],0==x__ :> True],True]===Length[#["stateVars"][t]]+1)&/@mods,*)
(*(Count[Cases[First@findEulerEqConstants[bondret[t,m],#],0==x__ :> True],True]===Length[#["stateVars"][t]]+1)&/@mods,*)
(*(Count[Cases[First@findEulerEqConstants[nombondret[t,m],#, True],0==x__ :> True],True]===Length[#["stateVars"][t]]+1)&/@mods*)
(*}*)
(*,*)
(*True*)
(*]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*eq for coefficients do not have t*)*)
(*If[longTest,*)
(*And@@Flatten@{*)
(*FreeQ[findEulerEqConstants[retc[t],#],t]&/@mods,*)
(*FreeQ[findEulerEqConstants[ret[t,j],#],t]&/@mods,*)
(*FreeQ[findEulerEqConstants[bondret[t,m],#],t]&/@mods,*)
(*FreeQ[findEulerEqConstants[nombondret[t,m],#, True],t]&/@mods*)
(*}*)
(*,*)
(*True*)
(*]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*If[longTest,*)
(*(*equations are the same for any time period*)*)
(*And@@Flatten@{*)
(*(findEulerEqConstants[retc[t],#]&/@mods)===(findEulerEqConstants[retc[t+1],#]&/@mods),*)
(*(findEulerEqConstants[ret[t,j],#]&/@mods)===(findEulerEqConstants[ret[t+1,j],#]&/@mods),*)
(*(findEulerEqConstants[bondret[t,m],#]&/@mods)===(findEulerEqConstants[bondret[t+1,m],#]&/@mods),*)
(*(findEulerEqConstants[nombondret[t,m],#, True]&/@mods)===(findEulerEqConstants[nombondret[t+1,m],#, True]&/@mods)*)
(*}*)
(*,*)
(*True*)
(*]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*If[longTest,*)
(*(*unknowns in Euler eq are in context "FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`"*)*)
(*{"FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`"}===DeleteDuplicates@*)
(*Flatten@{Map[Context[Evaluate[#]]&,Flatten@((Flatten@Rest@findEulerEqConstants[retc[t],#])[[;;,0]]&/@mods)],*)
(*Map[Context[Evaluate[#]]&,Flatten@((Flatten@Rest@findEulerEqConstants[ret[t,j],#])[[;;,0,0]]&/@mods)],*)
(*Map[Context[Evaluate[#]]&,Flatten@((Flatten@Rest@findEulerEqConstants[bondret[t,m],#])[[;;,0,0]]&/@mods)],*)
(*Map[Context[Evaluate[#]]&,Flatten@((Flatten@Rest@findEulerEqConstants[nombondret[t,m],#,True])[[;;,0,0]]&/@mods)]*)
(*}*)
(*,*)
(*True]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*each equation evaluates to True or False when evaluated numerically*)*)
(*checkBoolean[model_]:=Module[{e0,e1,e2,e3,e0p,e1p,e2p,e3p},*)
(*e0=findEulerEqConstants[retc[t],model];*)
(*e1=findEulerEqConstants[ret[t,1],model];*)
(*e2=findEulerEqConstants[bondret[t,m],model];*)
(*e3=findEulerEqConstants[nombondret[t,m],model, True];*)
(*e0p=Flatten@{Normal@model["parameters"],Thread[e0[[2]]->4],FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`Ewc->4};*)
(*e1p=Flatten@{e0p,FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefpd[_]->4,FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`Epd[_]->4};*)
(*e2p=Flatten@{e0p,FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefb[m_]->4};*)
(*e3p=Flatten@{e0p,FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefnb[m_]->4};*)
(*{e0[[1]]/.e0p,e1[[1]]/.e1p,e2[[1]]/.e2p,e3[[1]]/.e3p}*)
(*];*)
(*And@@(BooleanQ/@(Flatten@checkBoolean[modBY]))*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*End[];*)


(* ::Input:: *)
(*addBeginEnd[testFilePath,testContext];*)
(*{*)
(*tr[Evaluate@name]["TestReport"] ,*)
(*tr[Evaluate@name]["ActualOutput"] ,*)
(*tr[Evaluate@name]["ExpectedOutput"] ,*)
(*tr[Evaluate@name]["OutputTrueQ"]*)
(*}=runTests[testFilePath];*)
(*(*tableActualVsExpeected[testName_String];*)*)
(*cleanUp[];*)


(* ::Section:: *)
(*ComputationalEngine`CreateMomentsDatabase`*)


(* ::Section:: *)
(*ComputationalEngine`SolveEulerEq`*)


(* ::Input:: *)
(*name = First@NotebookRead[PreviousCell[CellStyle -> "Section"]];*)
(*makeDefinitions[name];*)


(* ::Input:: *)
(*Begin[Evaluate@testContext];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*longTest = False; (*fast and partial coverage (False) or slow and full coverage (True)*)*)
(*True*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*With[{context=context},*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Needs@context;*)
(*$ContextPath = DeleteDuplicates@Prepend[$ContextPath,"FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`"];*)
(*True*)
(*,"ConfirmResults"->confirm];*)
(*];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Off[General::stop];*)
(*If[Not@longTest,Off[FindRoot::cvmit]];*)
(**)
(*Get@Get[FileNameJoin[{"FernandoDuarte/LongRunRisk","Models.wl"}]] ;*)
(**)
(*msp=FernandoDuarte`LongRunRisk`Models;*)
(*modBY=msp["BY"];*)
(*modBKY=msp["BKY"];*)
(*modNRC=msp["NRC"];*)
(*modDES=msp["DES"];*)
(*modNRCStochVol=msp["NRCStochVol"];*)
(*mods=If[longTest,*)
(*{modBY,modBKY,modNRC,modDES,modNRCStochVol},*)
(*{modBKY,modDES}*)
(*];*)
(**)
(*(*testing functions*)*)
(**)
(*(*returns True if coefficients have expected form*)*)
(*coeffsQ[sol_,coeffName_,numStateVars_,numAssets_:0,bond_:0]:=And@@{*)
(*If[numAssets==0,*)
(*(*wc ratio: coefficients are indexed by 0, 1, 2...*)*)
(*(Sort@Cases[Keys/@sol,coeffName[i_Integer]:>i])===(Range[numStateVars+1]-1),*)
(*(*pd ratio or bond prices: coefficients are indexed by two integers, first one indexes stock number or maturity of bond, second one indexes state variables*)*)
(*(Sort@Tuples[*)
(*{*)
(*Range[numAssets]-bond,*)
(*Range[numStateVars+1]-1*)
(*}*)
(*])==(Sort@Cases[Keys/@sol,coeffName[i_Integer][j_Integer]:>{i,j}])*)
(*],*)
(*(*names match coeffName*)*)
(*And@@(MatchQ[#,coeffName]&/@Cases[Keys/@sol,var_[i_Integer][j_Integer]:>var]),*)
(*(*context is same as context of coeffName*)*)
(*And@@(MatchQ[#,StringDrop[ToString[coeffName],-1]]&/@Cases[Keys/@sol,var_[i_Integer][j_Integer]:>Context[var]]),*)
(*(*values are numbers*)*)
(*And@@(NumberQ/@(Values/@sol))*)
(*};*)
(**)
(*(*list with different options*)*)
(*opts={*)
(*(*single option*)*)
(*{"initialGuess" -> <|"Ewc"->{4.6},"Epd"->{{5.6}}|>}, (*updateCoeffsSol option*)*)
(* {"PrintResidualsNorm"->False},(*checks option*)*)
(* {"MaxIterations"->1},(*FindRoot option*)*)
(* {"FindRootOptions"->{"MaxIterations"->1}}, (*FindRoot option via updateCoeffsSol options*)*)
(**)
(*(*more than one option*)*)
(* {"initialGuess" -> <|"Ewc"->{4.6},"Epd"->{{5.6}}|>,"PrintResidualsNorm"->False},*)
(* {"initialGuess" -> <|"Ewc"->{4.6},"Epd"->{{5.6}}|>,"PrintResidualsNorm"->False,"MaxIterations"->1},*)
(* {"initialGuess" -> <|"Ewc"->{4.6},"Epd"->{{5.6}}|>,"MaxIterations"->1},*)
(* {"PrintResidualsNorm"->False,"MaxIterations"->1},*)
(**)
(* {"initialGuess" -> <|"Ewc"->{4.6},"Epd"->{{5.6}}|>,"PrintResidualsNorm"->False,"FindRootOptions"->{WorkingPrecision->$MachinePrecision}},*)
(* {"initialGuess" -> <|"Ewc"->{4.6},"Epd"->{{5.6}}|>,"PrintResidualsNorm"->False,"MaxIterations"->1,"FindRootOptions"->{WorkingPrecision->$MachinePrecision}},*)
(* {"initialGuess" -> <|"Ewc"->{4.6},"Epd"->{{5.6}}|>,"MaxIterations"->1,"FindRootOptions"->{WorkingPrecision->$MachinePrecision}},*)
(* {"PrintResidualsNorm"->False,"MaxIterations"->1,"FindRootOptions"->{WorkingPrecision->$MachinePrecision}}*)
(*};*)
(**)
(*(*same FindRootOptions and options to FindRoot*)*)
(*optsRepeated =*)
(*{*)
(*{"initialGuess" -> <|"Ewc"->{4.6},"Epd"->{{5.6}}|>,"PrintResidualsNorm"->False,"FindRootOptions"->{WorkingPrecision->$MachinePrecision},WorkingPrecision->$MachinePrecision},*)
(* {"initialGuess" -> <|"Ewc"->{4.6},"Epd"->{{5.6}}|>,"PrintResidualsNorm"->False,"MaxIterations"->1,"FindRootOptions"->{WorkingPrecision->$MachinePrecision},WorkingPrecision->$MachinePrecision},*)
(*{"initialGuess" -> <|"Ewc"->{4.6},"Epd"->{{5.6}}|>,"MaxIterations"->1,"FindRootOptions"->{WorkingPrecision->$MachinePrecision},WorkingPrecision->$MachinePrecision},*)
(*{"PrintResidualsNorm"->False,"MaxIterations"->1,"FindRootOptions"->{WorkingPrecision->$MachinePrecision},WorkingPrecision->$MachinePrecision},*)
(*{"PrintResidualsNorm"->False,"MaxIterations"->1,"FindRootOptions"->{"MaxIterations"->5}},*)
(*{"PrintResidualsNorm"->False,"MaxIterations"->1,"FindRootOptions"->{"MaxIterations"->5,WorkingPrecision->$MachinePrecision}};*)
(*{"PrintResidualsNorm"->False,"MaxIterations"->1,"FindRootOptions"->{"MaxIterations"->5,WorkingPrecision->$MachinePrecision},WorkingPrecision->$MachinePrecision}*)
(*};*)
(*If[longTest,*)
(*optsMany=Join[opts[[5;;-1]],optsRepeated];*)
(*,*)
(*optsMany=Join[opts[[5;;6]],optsRepeated[[1;;2]]];*)
(*];*)
(**)
(*Do[*)
(**)
(*(**********set up useful variables used throughout loop**********)*)
(*ind=0;(*counter for Do loop*)*)
(**)
(*(*convenience functions for different coefficients*)*)
(*numStateVars=Length[model["stateVars"][t]];*)
(*numStocks=model["numStocks"];*)
(**)
(*coeffsQWc[sol_]:=coeffsQ[sol,FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefwc,numStateVars];*)
(*coeffsQPd[sol_]:=coeffsQ[sol,Head@FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefpd,numStateVars,numStocks];*)
(*coeffsQBond[sol_,maxMaturity_]:=coeffsQ[sol,Head@FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefb,numStateVars,maxMaturity+1,1];*)
(*coeffsQNomBond[sol_,maxMaturity_]:=coeffsQ[sol,Head@FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefnb,numStateVars,maxMaturity+1,1];*)
(**)
(*(**********testing starts here**********)*)
(*FernandoDuarte`LongRunRisk`Tests`ComputationalEngine`SolveEulerEq`updateCoeffs=FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`updateCoeffs;*)
(**)
(*FernandoDuarte`LongRunRisk`Tests`ComputationalEngine`SolveEulerEq`updateCoeffsSol=FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`updateCoeffsSol;*)
(**)
(*FernandoDuarte`LongRunRisk`Tests`ComputationalEngine`SolveEulerEq`updateCoeffsWc=FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`updateCoeffsWc;*)
(**)
(*FernandoDuarte`LongRunRisk`Tests`ComputationalEngine`SolveEulerEq`updateCoeffsPd=FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`updateCoeffsPd;*)
(**)
(*FernandoDuarte`LongRunRisk`Tests`ComputationalEngine`SolveEulerEq`updateCoeffsBond=FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`updateCoeffsBond;*)
(**)
(*(*test: passing arguments works as intended*)*)
(*(*parse positional arguments correctly*)*)
(*newParameters={delta->0.99};*)
(*guessCoeffsSolution={A[0]->4.6};*)
(*If[longTest,*)
(*outTests[model["shortname"]][ind]=And@@{*)
(*updateCoeffs[model]==updateCoeffs[model,{}]==updateCoeffs[model,{},{}]==updateCoeffs[model,{},{},{}]==updateCoeffsSol[model,{},{}],*)
(*updateCoeffs[model,newParameters]==updateCoeffs[model,newParameters,{}]==updateCoeffs[model,newParameters,{},{}]==updateCoeffsSol[model,newParameters,{}],*)
(*updateCoeffs[model,newParameters, guessCoeffsSolution]==updateCoeffs[model,newParameters, guessCoeffsSolution]==updateCoeffs[model,newParameters, guessCoeffsSolution,{},{}]==updateCoeffsSol[model,newParameters, guessCoeffsSolution]*)
(*};*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(*];*)
(*(*separates positional arguments and optional arguments correctly*)*)
(*If[longTest,*)
(*outTests[model["shortname"]][ind]=Quiet[*)
(*And@@Flatten@{*)
(*Map[*)
(*coeffsQWc,*)
(*{*)
(*updateCoeffsSol[model,{},{},#],*)
(*updateCoeffs[model,{},{},Sequence@#],*)
(*updateCoeffs[model,{},{},Sequence@@#],*)
(*updateCoeffs[model,{},#],*)
(*updateCoeffs[model,Sequence@{},#],*)
(*updateCoeffs[model,Sequence@@{},#],*)
(*updateCoeffs[model,#],*)
(*updateCoeffs[model,Sequence@#],*)
(*updateCoeffs[model,Sequence@@#],*)
(*updateCoeffs[model,Most@#,Last@#],*)
(*updateCoeffs[model,Sequence[Most@#],Last@#]*)
(*}&/@opts[[1;;4]],*)
(*{2}*)
(*],*)
(**)
(*(*different ways to pass more than one option are equivalent*)*)
(*Map[*)
(*coeffsQWc,*)
(*{*)
(*updateCoeffsSol[model,{},{},#],*)
(*updateCoeffs[model,First@#,Rest@#],*)
(*updateCoeffs[model,First@#,Sequence[Rest@#]],*)
(*updateCoeffs[model,Sequence[First@#,Rest@#]],*)
(*updateCoeffs[model,Most@#,List@Last@#],*)
(*updateCoeffs[model,List@First@#,Rest@#]*)
(*}&/@optsMany,*)
(*{2}*)
(*]*)
(*}*)
(*];*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(*];*)
(**)
(*(**********tests for wealth consumption ratio coefficients**********)*)
(*optsWc={"MaxIterations"->100};*)
(*solWc=updateCoeffs[model,optsWc];*)
(**)
(*(*test: wrapper functions updateCoeffsSol and updateCoeffs give same answer as updateCoeffsWc*)*)
(*outTests[model["shortname"]][ind]=(solWc==updateCoeffsSol[model,{},{},optsWc]==updateCoeffsWc[model["coeffsSolution"]["wc"],model["params"],{},optsWc]);*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*(*******options work as intended*******)*)
(*If[longTest,*)
(*(*test: one iteration doesn't get far from initial guess*)*)
(*solWc1=updateCoeffs[model, "MaxIterations"->1,"initialGuess" -> <|"Ewc"->{3}|>];*)
(*solWc2=updateCoeffs[model, "MaxIterations"->1,"initialGuess" -> <|"Ewc"->{1}|>];*)
(*outTests[model["shortname"]][ind]=((FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`A[0]/.solWc1) > (FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`A[0]/.solWc2));*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*solWc1=updateCoeffs[model,"FindRootOptions"->{"MaxIterations"->1},"initialGuess" -> <|"Ewc"->{3}|>];*)
(*solWc2=updateCoeffs[model,"FindRootOptions"->{"MaxIterations"->1},"initialGuess" -> <|"Ewc"->{1}|>];*)
(*outTests[model["shortname"]][ind]=((FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`A[0]/.solWc1) > (FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`A[0]/.solWc2));*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*(*MaxIterations works*)*)
(*(*test: one iteration passing FindRoot option*)*)
(*m1=Block[{$MessagePrePrint=Sow,$MessageList={}},Reap[Module[{},updateCoeffs[model,"MaxIterations"->1,"initialGuess" -> <|"Ewc"->{4}|>];];$MessageList]*)
(*];*)
(*(*test: three iterations passing FindRoot option*)*)
(*m2=Block[{$MessagePrePrint=Sow,$MessageList={}},Reap[Module[{},updateCoeffs[model,"MaxIterations"->3,"initialGuess" -> <|"Ewc"->{4}|>];];$MessageList]*)
(*];*)
(*(*test: one iteration passing updateCoeffsSol option*)*)
(*m3=Block[{$MessagePrePrint=Sow,$MessageList={}},Reap[Module[{},updateCoeffs[model,"FindRootOptions"->{"MaxIterations"->1},"initialGuess" -> <|"Ewc"->{4}|>];];$MessageList]*)
(*];*)
(*(*test: three iterations passing updateCoeffsSol option*)*)
(*m4=Block[{$MessagePrePrint=Sow,$MessageList={}},Reap[Module[{},updateCoeffs[model,"FindRootOptions"->{"MaxIterations"->3},"initialGuess" -> <|"Ewc"->{4}|>];];$MessageList]*)
(*];*)
(*outTests[model["shortname"]][ind]=And@@{*)
(*ReleaseHold@Last@m1=={{1}},*)
(*ReleaseHold@Last@m2=={{3}},*)
(*ReleaseHold@Last@m3=={{1}},*)
(*ReleaseHold@Last@m4=={{3}}*)
(*};*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*(*test: when passing same FindRoot and updateCoeffsSol options, FindRoot option is used*)*)
(*m1=Block[{$MessagePrePrint=Sow,$MessageList={}},Reap[Module[{},updateCoeffs[model,"MaxIterations"->3,"FindRootOptions"->{"MaxIterations"->1},"initialGuess" -> <|"Ewc"->{4}|>];];$MessageList]*)
(*];*)
(*m2=Block[{$MessagePrePrint=Sow,$MessageList={}},Reap[Module[{},updateCoeffs[model,"FindRootOptions"->{"MaxIterations"->1},"MaxIterations"->3,"initialGuess" -> <|"Ewc"->{4}|>];];$MessageList]*)
(*];*)
(*m3=Block[{$MessagePrePrint=Sow,$MessageList={}},Reap[Module[{},updateCoeffs[model,"MaxIterations"->1,"FindRootOptions"->{"MaxIterations"->3},"initialGuess" -> <|"Ewc"->{4}|>];];$MessageList]*)
(*];*)
(*m4=Block[{$MessagePrePrint=Sow,$MessageList={}},Reap[Module[{},updateCoeffs[model,"FindRootOptions"->{"MaxIterations"->3},"MaxIterations"->1,"initialGuess" -> <|"Ewc"->{4}|>];];$MessageList]*)
(*];*)
(*outTests[model["shortname"]][ind]=And@@{*)
(*ReleaseHold@Last@m1=={{3}},*)
(*ReleaseHold@Last@m2=={{3}},*)
(*ReleaseHold@Last@m3=={{1}},*)
(*ReleaseHold@Last@m4=={{1}}*)
(*};*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*(*PrintResidualsNorm works*)*)
(*(*test: do not print residual*)*)
(*m1=Block[{$MessagePrePrint=Sow,$MessageList={}},Reap[Module[{},updateCoeffs[model,"PrintResidualsNorm"->False];];$MessageList]*)
(*];*)
(*(*test: print residual*)*)
(*m2=Block[{$MessagePrePrint=Sow,$MessageList={}},Reap[Module[{},updateCoeffs[model,"PrintResidualsNorm"->True];];$MessageList]*)
(*];*)
(*(*test: check m1 did not print, m2 printed correct message*)*)
(*outTests[model["shortname"]][ind]=(ReleaseHold@m1=={{},{}});*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*outTests[model["shortname"]][ind]=(First@m2=={HoldForm@(FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`checks::norm)});*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*outTests[model["shortname"]][ind]=NumberQ@(ReleaseHold@First@Flatten@Last@m2);*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*(*CheckResiduals works*)*)
(*(*test: do not check if root finding residual (error) is small*)*)
(*c1=Not@TrueQ[CheckAbort[Check[updateCoeffs[model,"CheckResiduals"->False],Abort[],(FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`checks::largeresid)],True]];*)
(*(*test: check if root finding residual (error) is small, abort if error above tolerance*)*)
(*c2=TrueQ[CheckAbort[Check[updateCoeffs[model,"CheckResiduals"->True],Abort[],(FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`checks::largeresid)],True]];*)
(*outTests[model["shortname"]][ind]=And@@{c1,c2};*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*(*Tol works*)*)
(*(*test: big tolerance, computation does not abort*)*)
(*c1=Not@TrueQ[CheckAbort[Check[updateCoeffs[model,"CheckResiduals"->True,"Tol"->1],Abort[],(FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`checks::largeresid)],True]];*)
(*(*test: low tolerance, computation aborts*)*)
(*c2=TrueQ[CheckAbort[Check[updateCoeffs[model,"CheckResiduals"->True,"Tol"->10.^-20],Abort[],(FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`checks::largeresid)],True]];*)
(*outTests[model["shortname"]][ind]=And@@{c1,c2};*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(*];*)
(*(*ReturnPd works*)*)
(*Ewc0=4.6;*)
(*(*test: do not return pd coefficients*)*)
(*outTests[model["shortname"]][ind]=coeffsQWc[updateCoeffs[model,"UpdatePd"->False,"initialGuess" -><|"Ewc"->{Ewc0},"Epd"->{{5.5}}|>]];*)
(*ind=ind;(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*(*test: return pd coefficients*)*)
(*coeffsWcPd=updateCoeffs[model,"UpdatePd"->True,"initialGuess" -><|"Ewc"->{Ewc0},"Epd"->{{5.5}}|>];*)
(*(*test: separate wc and pd coefficients*)*)
(*coeffsWc=FilterRules[coeffsWcPd,FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefwc[_Integer]];*)
(*coeffsPd=FilterRules[coeffsWcPd,FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefpd[_Integer]];*)
(*(*test: check coefficients have expected form*)*)
(*outTests[model["shortname"]][ind]=coeffsQWc[coeffsWc];*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*outTests[model["shortname"]][ind]=coeffsQPd[coeffsPd];*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*If[longTest,*)
(*(*test: wc coefficients are the same when pd coefficients are or are not returned*)*)
(*outTests[model["shortname"]][ind]=(updateCoeffs[model,"initialGuess" -><|"Ewc"->{Ewc0}|>]==updateCoeffs[model,"UpdatePd"->False,"initialGuess" -><|"Ewc"->{Ewc0},"Epd"->{{5.5}}|>]);*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*(*test: updateCoeff inherits options from updateCoeffsSol, checks*)*)
(*outTests[model["shortname"]][ind]=And@@{*)
(*SubsetQ[Options[updateCoeffs],Options[FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`updateCoeffsSol]],*)
(*SubsetQ[Options[updateCoeffs],Options[FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`checks]]*)
(*};*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*(*pass initial guess in updateCoeffs, updateCoeffsSol, updateCoeffsWc*)*)
(*oldOptions=Options[updateCoeffs];(*save options to restore later*)*)
(*oldOptionsSol=Options[FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`updateCoeffsSol];(*save options to restore later*)*)
(*oldOptionsWc=Options[FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`updateCoeffsWc];(*save options to restore later*)*)
(*ig=1;(*new initial guess*)*)
(*(*test: initial guess as argument*)*)
(*outTests[model["shortname"]][ind]=(updateCoeffs[model,"initialGuess" -><|"Ewc"->{ig}|>]==updateCoeffsSol[model,{},{},"initialGuess" -><|"Ewc"->{ig}|>]==*)
(*updateCoeffsWc[model["coeffsSolution"]["wc"],model["parameters"],{},"Ewc0"->ig]);*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*(*initial guess as default in options*)*)
(*(*test: default arguments of updateCoeffs*)SetOptions[updateCoeffs,"initialGuess" -><|"Ewc"->{ig}|>];*)
(*outTests[model["shortname"]][ind]=(updateCoeffs[model,"initialGuess" -><|"Ewc"->{ig}|>]==updateCoeffs[model]);*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(*Options[updateCoeffs]=oldOptions;(*restore options*)*)
(**)
(*(*test: default arguments of updateCoeffsSol*)*)
(*SetOptions[FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`updateCoeffsSol,"initialGuess" -><|"Ewc"->{ig}|>];*)
(*outTests[model["shortname"]][ind]=(updateCoeffsSol[model,{},{}]==updateCoeffsSol[model,{},{},"initialGuess" -><|"Ewc"->{ig}|>]==updateCoeffs[model,"initialGuess" -><|"Ewc"->{ig}|>]);*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*outTests[model["shortname"]][ind]=(Not@TrueQ@(updateCoeffsSol[model,{},{},MaxIterations->1]==updateCoeffs[model,MaxIterations->1]));*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(*Options[FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`updateCoeffsSol]=oldOptionsSol;(*restore options*)*)
(**)
(*(*test: default arguments of updateCoeffsWc*)*)
(*SetOptions[FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`updateCoeffsWc,"Ewc0" -> ig]; *)
(*outTests[model["shortname"]][ind]=(updateCoeffsWc[model["coeffsSolution"]["wc"],model["parameters"],{}]==updateCoeffsWc[model["coeffsSolution"]["wc"],model["parameters"],{},"Ewc0" -> ig]==updateCoeffs[model,"initialGuess" -><|"Ewc"->{ig}|>]);*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*outTests[model["shortname"]][ind]=(Not@TrueQ@(updateCoeffsWc[model["coeffsSolution"]["wc"],model["parameters"],{},MaxIterations->1]==updateCoeffs[model,MaxIterations->1]));*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(*Options[FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`updateCoeffsWc]=oldOptionsWc;(*restore options*)*)
(**)
(*oldOptions=Options[updateCoeffs];(*save options to restore later*)*)
(*(*test: use defaults for updateCoeffs for any options inherited from updateCoeffsSol, check*)*)
(*optsUpdateCoeff={*)
(*{"initialGuess" -> <|"Ewc"->{4.6},"Epd"->{{4.6}}|>},(*updateCoeffsSol option*)*)
(* {"PrintResidualsNorm"->True}(*checks option*)*)
(*};*)
(*outTests[model["shortname"]][ind]=And@@Flatten@({*)
(*SetOptions[updateCoeffs,#];*)
(*out=updateCoeffs[model,#]==updateCoeffs[model];*)
(*Options[updateCoeffs]=oldOptions;(*restore options*)*)
(*out*)
(*}&/@optsUpdateCoeff);*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*(*test: can't set defaults for updateCoeffs for FindRoot options since they are not inherited*)*)
(*optsBad={*)
(*{MaxIterations->100}, (*FindRoot option*)*)
(* {PrecisionGoal->$MachinePrecision}(*FindRoot option*)*)
(*};*)
(*outTests[model["shortname"]][ind]=And@@Flatten@({*)
(*m=Block[{$MessagePrePrint=Sow,$MessageList={}},Reap[*)
(*Module[*)
(*{},*)
(*SetOptions[updateCoeffs,#]*)
(*];*)
(*$MessageList*)
(*]*)
(*];*)
(*Options[updateCoeffs]=oldOptions;*)
(*First@First@m==HoldForm@SetOptions::optnf*)
(*}&/@optsBad);*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*(*can set defaults using the option "FindRootOptions" inherited from updateCoeffsSol*)*)
(*optsFindRoot={*)
(*"FindRootOptions"->{MaxIterations->1},(*has a default in "FindRootOptions"*)*)
(*"FindRootOptions"->{AccuracyGoal->2}(*does not have a default in "FindRootOptions"*)*)
(*};(*can set defaults using the default options from FindRoot only for options without a default in "FindRootOptions"*)*)
(*oldFindRootOpts = Options[FindRoot];(*save options to restore at the end*)*)
(*(*find options with a default value in "FindRootOptions" option in updateCoeffs*)*)
(*withFindRootOptionDefault=Keys@("FindRootOptions"/.Options[updateCoeffs]);*)
(*outTests[model["shortname"]][ind]=And@@Flatten@({*)
(*SetOptions[updateCoeffs,#];(*test: change default option "FindRootOptions" in updateCoeffs*)*)
(*out1=updateCoeffs[model,#]==updateCoeffs[model];*)
(*Options[updateCoeffs]=oldOptions;(*restore options*)*)
(*Unprotect[FindRoot];*)
(*SetOptions[FindRoot,Last@#];(*change default option in FindRoot*)*)
(*out2=updateCoeffs[model,#]==updateCoeffs[model];*)
(*(*test: if option has a default in "FindRootOptions", FindRoot option does not override it*)*)
(*out2=If[MemberQ[withFindRootOptionDefault,First@First@Last@#],Not@TrueQ@out2,out2];*)
(*Options[FindRoot]=oldFindRootOpts;*)
(*Protect[FindRoot];*)
(*{out1,out2}*)
(*}&/@optsFindRoot);*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(*];*)
(*outTests[model["shortname"]][ind]=And@@{*)
(*(*test: pass interval as initial guess works*)*)
(*coeffsQWc[updateCoeffs[model,"initialGuess" -> <|"Ewc"->{1,8}|>]],*)
(*(*test: pass interval interval and initial guess works*)*)
(*coeffsQWc[updateCoeffs[model,"initialGuess" -> <|"Ewc"->{4,1,8}|>]]*)
(*};*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*If[longTest,*)
(*(*test: pass approximate or exact numbers*)*)
(*outTests[model["shortname"]][ind]=And@@{*)
(*coeffsQWc[updateCoeffs[model,"initialGuess" -> <|"Ewc"->{4.}|>]]==coeffsQWc[updateCoeffs[model,"initialGuess" -> <|"Ewc"->{4}|>]],*)
(*coeffsQWc[updateCoeffs[model,"initialGuess" -> <|"Ewc"->{1.,8.}|>]]==coeffsQWc[updateCoeffs[model,"initialGuess" -> <|"Ewc"->{1,8}|>]],*)
(*coeffsQWc[updateCoeffs[model,"initialGuess" -> <|"Ewc"->{4.,1.,8.}|>]]==coeffsQWc[updateCoeffs[model,"initialGuess" -> <|"Ewc"->{4,1,8}|>]]*)
(*};*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(*];*)
(*(**********tests for bond coefficients**********)*)
(*(*updateCoeffsBond*)*)
(*maxMaturity=12;*)
(**)
(*(*test: coefficients have expected form*)*)
(*solBond=updateCoeffsBond[model["coeffsSolution"]["bond"],model["params"],{},maxMaturity,solWc];*)
(*solNomBond=updateCoeffsBond[model["coeffsSolution"]["nombond"],model["params"],{},maxMaturity,solWc];*)
(*outTests[model["shortname"]][ind]=And@@{*)
(*coeffsQBond[solBond,maxMaturity],*)
(*coeffsQNomBond[solNomBond,maxMaturity]*)
(*};*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*(*newParameters*)*)
(*newBondParams={FernandoDuarte`LongRunRisk`Model`Parameters`psi->(0.1+FernandoDuarte`LongRunRisk`Model`Parameters`psi/.model["params"])};*)
(*solWcNewBondParams=updateCoeffs[model,newBondParams,optsWc];*)
(*solBondNew=updateCoeffsBond[model["coeffsSolution"]["bond"],model["params"],newBondParams,maxMaturity,solWcNewBondParams];*)
(*solNomBondNew=updateCoeffsBond[model["coeffsSolution"]["nombond"],model["params"],newBondParams,maxMaturity,solWcNewBondParams];*)
(*outTests[model["shortname"]][ind]=And@@{*)
(*coeffsQBond[solBondNew,maxMaturity],*)
(*coeffsQNomBond[solNomBondNew,maxMaturity],*)
(*Not[solBond===solBondNew],*)
(*Not[solNomBond===solNomBondNew]*)
(*};*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*(*maxMaturity*)*)
(*oldMaxMaturity=maxMaturity; (*save to restore later*)*)
(*maxMaturity=2;*)
(*(*test: coefficients have expected form*)*)
(*solBond=updateCoeffsBond[model["coeffsSolution"]["bond"],model["params"],{},maxMaturity,solWc];*)
(*solNomBond=updateCoeffsBond[model["coeffsSolution"]["nombond"],model["params"],{},maxMaturity,solWc];*)
(*outTests[model["shortname"]][ind]=And@@{*)
(*coeffsQBond[solBond,maxMaturity],*)
(*coeffsQNomBond[solNomBond,maxMaturity],*)
(*Range[0,maxMaturity]==(Sort@DeleteDuplicates@Cases[Keys@solBond,x_[i_][j_]:>i]),*)
(*Range[0,maxMaturity]==(Sort@DeleteDuplicates@Cases[Keys@solNomBond,x_[i_][j_]:>i])*)
(*};*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(*maxMaturity=oldMaxMaturity; (*restore original value*)*)
(*If[longTest,*)
(*(*test: pass options for RecurrenceTable*)*)
(*solBond=updateCoeffsBond[model["coeffsSolution"]["bond"],model["params"],{},maxMaturity,solWc,"Method"->Automatic,"Precision"->1];*)
(*solNomBond=updateCoeffsBond[model["coeffsSolution"]["nombond"],model["params"],{},maxMaturity,solWc,"Method"->Automatic,"Precision"->1];*)
(*outTests[model["shortname"]][ind]=And@@{*)
(*coeffsQBond[solBond,maxMaturity],*)
(*coeffsQNomBond[solNomBond,maxMaturity]*)
(*};*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*(*updateCoeffs*)*)
(*(*test: updateCoeffs matches updateCoeffsBond*)*)
(*outTests[model["shortname"]][ind]=And@@{*)
(*FilterRules[updateCoeffs[model,"UpdateBond"->True,"MaxMaturity"->maxMaturity],FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefb[_]]===*)
(*updateCoeffsBond[model["coeffsSolution"]["bond"],model["params"],{},maxMaturity,solWc],*)
(*FilterRules[updateCoeffs[model,"UpdateNomBond"->True,"MaxMaturity"->maxMaturity],FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefnb[_]]===*)
(*updateCoeffsBond[model["coeffsSolution"]["nombond"],model["params"],{},maxMaturity,solWc]*)
(*};*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*outTests[model["shortname"]][ind]=And@@{*)
(*Sort@FilterRules[updateCoeffs[model,"UpdateBonds"->True,"MaxMaturity"->maxMaturity],FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefb[_]|FernandoDuarte`LongRunRisk`Model`EndogenousEq`Private`coefnb[_]]===Sort@Join[updateCoeffsBond[model["coeffsSolution"]["bond"],model["params"],{},maxMaturity,solWc],updateCoeffsBond[model["coeffsSolution"]["nombond"],model["params"],{},maxMaturity,solWc]]*)
(*};*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*(*PrintResidualsNorm works*)*)
(*(*test: do not print residual*)*)
(*m1=Block[{$MessagePrePrint=Sow,$MessageList={}},Reap[Module[{},updateCoeffs[model,"UpdateBond"->True,"PrintResidualsNorm"->False];];$MessageList]*)
(*];*)
(*(*test: print residual*)*)
(*m2=Block[{$MessagePrePrint=Sow,$MessageList={}},Reap[Module[{},updateCoeffs[model,"UpdateBond"->True,"PrintResidualsNorm"->True];];$MessageList]*)
(*];*)
(**)
(*(*test: check m1 did not print, m2 printed correct message*)*)
(*outTests[model["shortname"]][ind]=(ReleaseHold@m1=={{},{}});*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*outTests[model["shortname"]][ind]=(MemberQ[ReleaseHold@First@m2,FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`checks::norm ]);*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*outTests[model["shortname"]][ind]=NumberQ@(ReleaseHold@First@Flatten@Last@m2);*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*(*CheckResiduals works*)*)
(*(*test: do not check if root finding residual (error) is small*)*)
(*c1=Not@TrueQ[CheckAbort[Check[updateCoeffs[model,"UpdateBond"->True,"CheckResiduals"->False],Abort[],(FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`checks::largeresid)],True]];*)
(*(*test: check if root finding residual (error) is small, abort if error above tolerance*)*)
(*c2=TrueQ[CheckAbort[Check[updateCoeffs[model,"UpdateBond"->True,"CheckResiduals"->True],Abort[],(FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`checks::largeresid)],True]];*)
(*outTests[model["shortname"]][ind]=And@@{c1,c2};*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(**)
(*(*Tol works*)*)
(*(*test: big tolerance, computation does not abort*)*)
(*c1=Not@TrueQ[CheckAbort[Check[updateCoeffs[model,"UpdateBond"->True,"CheckResiduals"->True,"Tol"->1],Abort[],(FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`checks::largeresid)],True]];*)
(*(*test: low tolerance, computation aborts*)*)
(*c2=TrueQ[CheckAbort[Check[updateCoeffs[model,"UpdateBond"->True,"CheckResiduals"->True,"Tol"->10.^-20],Abort[],(FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`Private`checks::largeresid)],True]];*)
(*outTests[model["shortname"]][ind]=And@@{c1,c2};*)
(*(*Echo[{ind,outTests[model["shortname"]][ind]},"ind, outTests"];*)*)
(*ind=ind+1;*)
(*];*)
(*,*)
(*{model,mods}*)
(*];(*Do*)*)
(**)
(*noMissingTest={};*)
(*Do[*)
(*testNumber=*)
(*Sort@Cases[Keys@SubValues@outTests,Verbatim[HoldPattern][outTests[model["shortname"]][i_Integer]]:>i];*)
(*AppendTo[noMissingTest,Range[0,Max[testNumber]]==testNumber];*)
(*,*)
(*{model,mods}*)
(*];*)
(**)
(*out=And@@{*)
(*And@@noMissingTest,*)
(*And@@Values@SubValues@outTests*)
(*};*)
(*(*Echo[out,"out"];*)
(*Unprotect[$MessageList];*)
(*$MessageList={};*)
(*Protect[$MessageList];*)
(*Echo[$MessageList,"message list"];*)*)
(*On[General::stop];*)
(*On[FindRoot::cvmit];*)
(**)
(*out*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*End[];*)


(* ::Input:: *)
(*addBeginEnd[testFilePath,testContext];*)
(*{*)
(*tr[Evaluate@name]["TestReport"] ,*)
(*tr[Evaluate@name]["ActualOutput"] ,*)
(*tr[Evaluate@name]["ExpectedOutput"] ,*)
(*tr[Evaluate@name]["OutputTrueQ"]*)
(*}=runTests[testFilePath];*)
(*(*tableActualVsExpeected[testName_String];*)*)
(*cleanUp[];*)


(* ::Section:: *)
(*Tools`NiceOutput`*)


(* ::Input:: *)
(*name = First@NotebookRead[PreviousCell[CellStyle -> "Section"]];*)
(*makeDefinitions[name];*)


(* ::Input:: *)
(*Begin[Evaluate@testContext];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*longTest = False; (*fast and partial coverage (False) or slow and full coverage (True)*)*)
(*True*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Get@Get[FileNameJoin[{"FernandoDuarte/LongRunRisk","Models.wl"}]] ;*)
(*msp=If[longTest,*)
(*FernandoDuarte`LongRunRisk`Models,*)
(*KeyTake[FernandoDuarte`LongRunRisk`Models,{"BY","BKY","NRC","DES","NRCStochVol"}]*)
(*];*)
(*modBY=msp["BY"];*)
(*modBKY=msp["BKY"];*)
(*modNRC=msp["NRC"];*)
(*modDES=msp["DES"];*)
(*modNRCStochVol=msp["NRCStochVol"];*)
(*True*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*With[{context=context},*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Needs@context;*)
(*$ContextPath = DeleteDuplicates@Prepend[$ContextPath,"FernandoDuarte`LongRunRisk`Tools`NiceOutput`Private`"];*)
(*True*)
(*,"ConfirmResults"->confirm];*)
(*]*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*MemberQ[$ContextPath,"FernandoDuarte`LongRunRisk`Tools`NiceOutput`"]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*should be True if Info can be found*)*)
(*	Not[Names["*info"]==={}]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*table with model info*)*)
(*myModelsInfo=PacletizedResourceFunctions`SetSymbolsContext@info[msp];*)
(*And@@{*)
(*Head[myModelsInfo]===Column,*)
(*Head[myModelsInfo[[1]]]===List,*)
(*Head[myModelsInfo[[1,1]]]===OpenerView,*)
(*And@@(MatchQ[#,Grid]&/@(Head/@myModelsInfo[[1,;;,1,2]]))*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*check that Info is correct when model key does not match shortname*)*)
(*justBY=<|"BY"->msp["BY"]|>;*)
(*infoBY=PacletizedResourceFunctions`SetSymbolsContext@info[justBY];*)
(*newBY=<|"myModel"->msp["BY"]|>;*)
(*infoNewBY=PacletizedResourceFunctions`SetSymbolsContext@info[newBY];*)
(*And@@{*)
(*infoBY[[1,1,1,1]]=="BY",*)
(*PacletizedResourceFunctions`SetSymbolsContext@(infoBY[[1,1,1,2,1,4,1,1,2,1,1,1,1]])===PacletizedResourceFunctions`SetSymbolsContext@(x[t]),*)
(*infoNewBY[[1,1,1,1]]=="BY",*)
(*PacletizedResourceFunctions`SetSymbolsContext@(infoNewBY[[1,1,1,2,1,4,1,1,2,1,1,1,1]])===PacletizedResourceFunctions`SetSymbolsContext@(x[t])*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*should all be True if formatting is correct*)*)
(*And@@{*)
(*Head[infoBY]===Column,*)
(*Head[infoBY[[1]]]===List,*)
(*Head[infoBY[[1,1]]]===OpenerView,*)
(*And@@(MatchQ[#,Grid]&/@(Head/@infoBY[[1,;;,1,2]])),*)
(**)
(*Head[infoNewBY]===Column,*)
(*Head[infoNewBY[[1]]]===List,*)
(*Head[infoNewBY[[1,1]]]===OpenerView,*)
(*And@@(MatchQ[#,Grid]&/@(Head/@infoNewBY[[1,;;,1,2]]))*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*With[{localPi=3.14},*)
(*{*)
(*FernandoDuarte`LongRunRisk`Tools`NiceOutput`Private`numberFormattingTemplate[3.14],*)
(*FernandoDuarte`LongRunRisk`Tools`NiceOutput`Private`numberFormattingTemplate[3.14,NumberMarks->True],*)
(*FernandoDuarte`LongRunRisk`Tools`NiceOutput`Private`numberFormattingTemplate[3.14,NumberMarks->False],*)
(*FernandoDuarte`LongRunRisk`Tools`NiceOutput`Private`numberFormattingTemplate[localPi],*)
(*FernandoDuarte`LongRunRisk`Tools`NiceOutput`Private`numberFormattingTemplate[localPi,NumberMarks->True],*)
(*FernandoDuarte`LongRunRisk`Tools`NiceOutput`Private`numberFormattingTemplate[localPi,NumberMarks->False],*)
(*FernandoDuarte`LongRunRisk`Tools`NiceOutput`Private`numberFormattingTemplate[\[CapitalPi]],*)
(*FernandoDuarte`LongRunRisk`Tools`NiceOutput`Private`numberFormattingTemplate[\[CapitalPi],CharacterEncoding->"ASCII"],*)
(*FernandoDuarte`LongRunRisk`Tools`NiceOutput`Private`numberFormattingTemplate[Pi],*)
(*FernandoDuarte`LongRunRisk`Tools`NiceOutput`Private`numberFormattingTemplate[N[Pi]],*)
(*FernandoDuarte`LongRunRisk`Tools`NiceOutput`Private`numberFormattingTemplate[3.14*10^(-7)],*)
(*FernandoDuarte`LongRunRisk`Tools`NiceOutput`Private`numberFormattingTemplate[Flatten[{FernandoDuarte`LongRunRisk`Tools`NiceOutput`Private`stripContext[delta]/2/.FernandoDuarte`LongRunRisk`Tools`NiceOutput`Private`stripContext[{delta->0.99}]}]]*)
(*}*)
(*]==={"3.14","3.14`","3.14","3.14","3.14`","3.14","\[CapitalPi]","\\[CapitalPi]","3.141592653589793","3.141592653589793","3.14*^-7","{0.495}"}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*should be True if string has linebreaks \n and tabs \t*)*)
(*Not@StringFreeQ[FernandoDuarte`LongRunRisk`Tools`NiceOutput`Private`stringFormattingTemplate["Long-run risk model with stochastic volatility in the original 2004 paper by Bansal and Yaron"],"\t"|"\n"]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*End[];*)


(* ::Input:: *)
(*addBeginEnd[testFilePath,testContext];*)
(*{*)
(*tr[Evaluate@name]["TestReport"] ,*)
(*tr[Evaluate@name]["ActualOutput"] ,*)
(*tr[Evaluate@name]["ExpectedOutput"] ,*)
(*tr[Evaluate@name]["OutputTrueQ"]*)
(*}=runTests[testFilePath];*)
(*(*tableActualVsExpeected[testName_String];*)*)
(*cleanUp[];*)


(* ::Section:: *)
(*Tools`TimeAggregation`*)


(* ::Input:: *)
(*name = First@NotebookRead[PreviousCell[CellStyle -> "Section"]];*)
(*makeDefinitions[name];*)


(* ::Input:: *)
(*Begin[Evaluate@testContext];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*longTest = False; (*fast and partial coverage (False) or slow and full coverage (True)*)*)
(*True*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*With[{context=context},*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Off[General::stop];*)
(*Needs@context;*)
(*True*)
(*,"ConfirmResults"->confirm];*)
(*];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*MemberQ[$ContextPath,"FernandoDuarte`LongRunRisk`Tools`TimeAggregation`"];*)
(*True*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(* growth (lowercase g) in context "FernandoDuarte`LongRunRisk`TimeAggregation`" should be found and test should give True *)*)
(*Not[Names["*growth"]==={}]*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*tests Growth*)*)
(*(*dc*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*tent-shaped coefficients*)*)
(*And@@{*)
(*growth[dc,t]==dc[t],*)
(*growth[dc,t,"TimeAggregation"->1,"numPeriods"->1]==dc[t]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*tent-shaped coefficients*)*)
(*And@@{*)
(*growth[dc,t,"TimeAggregation"->3,"numPeriods"->1]==1/3 (dc[-4+t]+2 dc[-3+t]+3 dc[-2+t]+2 dc[-1+t]+dc[t]),*)
(*(growth[dc,t,"TimeAggregation"->12,"numPeriods"->1]/.Plus->List/.Times->List/.dc[{x__,t}]->-x/.dc[t]->0)=={{1/12,22},{1/6,21},{1/4,20},{1/3,19},{5/12,18},{1/2,17},{7/12,16},{2/3,15},{3/4,14},{5/6,13},{11/12,12},11,{11/12,10},{5/6,9},{3/4,8},{2/3,7},{7/12,6},{1/2,5},{5/12,4},{1/3,3},{1/4,2},{1/6,1},{1/12,0}}*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*expanssion around v0*)*)
(*(*constant v0, v0 has different number of arguments*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j,h,k,v,im},0.0015]]==0.` +0.3328334585207629` dc[-4+t]+0.6661665418542368` dc[-3+t]+dc[-2+t]+0.6671665414792372` dc[-1+t]+0.33383345814576315` dc[t],*)
(*growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j,h,k,v},0.0015]]==0.` +0.3328334585207629` dc[-4+t]+0.6661665418542368` dc[-3+t]+dc[-2+t]+0.6671665414792372` dc[-1+t]+0.33383345814576315` dc[t],*)
(*growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j,h,k},0.0015]]==0.` +0.3328334585207629` dc[-4+t]+0.6661665418542368` dc[-3+t]+dc[-2+t]+0.6671665414792372` dc[-1+t]+0.33383345814576315` dc[t],*)
(*growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j,h},0.0015]]==0.` +0.3328334585207629` dc[-4+t]+0.6661665418542368` dc[-3+t]+dc[-2+t]+0.6671665414792372` dc[-1+t]+0.33383345814576315` dc[t],*)
(*(*constant v0, different symbols as arguments*)*)
(*growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j},0.0015]]==0.` +0.3328334585207629` dc[-4+t]+0.6661665418542368` dc[-3+t]+dc[-2+t]+0.6671665414792372` dc[-1+t]+0.33383345814576315` dc[t],*)
(*growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t},0.0015]]==0.` +0.3328334585207629` dc[-4+t]+0.6661665418542368` dc[-3+t]+dc[-2+t]+0.6671665414792372` dc[-1+t]+0.33383345814576315` dc[t],*)
(*growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{},0.0015]]==0.` +0.3328334585207629` dc[-4+t]+0.6661665418542368` dc[-3+t]+dc[-2+t]+0.6671665414792372` dc[-1+t]+0.33383345814576315` dc[t]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*v0 as a function of t*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*Simplify@growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j,h,k,v,im},t]]==1/(1+E^t+E^(2 t)) (dc[-4+t]+(1+E^t) dc[-3+t]+dc[-2+t]+E^t dc[-2+t]+E^(2 t) dc[-2+t]+E^t dc[-1+t]+E^(2 t) dc[-1+t]+E^(2 t) dc[t])*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*v0 as a function of h*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*FreeQ[growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j,h,k,v,im},If[h==12,h12,hnot12]]],h12],*)
(*FreeQ[growth[dc,t,"TimeAggregation"->12,"numPeriods"->1,"v0"->Function[{t,j,h,k,v,im},If[h==12,h12,hnot12]]],hnot12]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*for v0 independent of j, constant term in expansion should be 0*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*0===(Coefficient[growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j,h,k,v,im},-1/(h+1)]]/.dc[__]->dcX,dcX,0]//FullSimplify),*)
(*0===(Coefficient[growth[dc,t,"TimeAggregation"->3,"numPeriods"->3,"v0"->Function[{t,j,h,k,v,im},h^2]]/.dc[__]->dcX,dcX,0]//FullSimplify),*)
(*0===(Coefficient[growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j,h,k,v,im},im]]/.dc[__]->dcX,dcX,0]//FullSimplify),*)
(*0===(Coefficient[growth[dc,t,"TimeAggregation"->3,"numPeriods"->3,"v0"->Function[{t,j,h,k,v,im},v]]/.dc[__]->dcX,dcX,0]//FullSimplify),*)
(*0===(Coefficient[growth[dd,t,i,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j,h,k,v,im},im]]/.dd[__,i]->ddX,ddX,0]//FullSimplify)*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*for v0(t,h,j) independent of j, constant term in expansion should be 0*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(**)
(*arbitraryFun1=Function[{t,j,h,k,v},Sqrt[h]];*)
(*arbitraryFun2=Function[{t,j,h,k,v},If[v==dd,Sqrt[h],Cos[h]]];*)
(*arbitraryFun3=Function[{t,j,h,k,v},-h];*)
(*arbitraryFun4=Function[{t,j,h,k,v},Sqrt[h]t -k^2];*)
(*arbitraryFun5=Function[{t,j,h,k,v},If[v==dd,Sqrt[h]Sqrt[t],Exp[t]Cos[h]]];*)
(*arbitraryFun6=Function[{t,j,h,k,v},-h*t*k];*)
(*And@@{*)
(*0===(Coefficient[growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j,h,k,v,im},F[h,v,im]]]/.dc[__]->dcX,dcX,0]//FullSimplify)/.F->arbitraryFun1//N,*)
(*0===(Coefficient[growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j,h,k,v,im},F[h,v,im]]]/.dc[__]->dcX,dcX,0]//FullSimplify)/.F->arbitraryFun2//N,*)
(*0===(Coefficient[growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j,h,k,v,im},F[h,v,im]]]/.dc[__]->dcX,dcX,0]//FullSimplify)/.F->arbitraryFun3//N,*)
(*0===(Coefficient[growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j,h,k,v,im},F[h,v,im]]]/.dc[__]->dcX,dcX,0]//FullSimplify)/.F->arbitraryFun4//N,*)
(*0===(Coefficient[growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j,h,k,v,im},F[h,v,im]]]/.dc[__]->dcX,dcX,0]//FullSimplify)/.F->arbitraryFun5//N,*)
(*0===(Coefficient[growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j,h,k,v,im},F[h,v,im]]]/.dc[__]->dcX,dcX,0]//FullSimplify)/.F->arbitraryFun6//N*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*dependence on j implies constant term in expansion is not necessarily 0*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*Not[0===Coefficient[growth[dc,t,"TimeAggregation"->3,"numPeriods"->3,"v0"->Function[{t,j,h,k,v,im},j]]/.dc[__]->dcX,dcX,0]//N]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*v0 as a function of j*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j},j]]==(-7-3 E^4+dc[-4+t]+dc[-3+t]+E^4 dc[-3+t])/(1+E^4+E^7)+dc[-2+t]+dc[-1+t]+dc[t]+(1-dc[-1+t]-dc[t]-E dc[t])/(1+2 E)-Log[1+1/E^7+1/E^3]+Log[2+1/E]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*v0 as a function of v*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*Not@FreeQ[growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j,h,k,v,im},If[v===dc,Edc,0]]],Edc],*)
(*FreeQ[growth[pi,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j,h,k,v,im},If[v===dc,Edc,0]]],Edc],*)
(*Not@FreeQ[growth[dd,t,i,"TimeAggregation"->12,"numPeriods"->1,"v0"->Function[{t,j,h,k,v,im},If[v===dd,Edd,0]]],Edd],*)
(*FreeQ[growth[dc,t,"TimeAggregation"->12,"numPeriods"->1,"v0"->Function[{t,j,h,k,v,im},If[v===dd,Edd,0]]],Edd]*)
(*}*)
(*,"ConfirmResults"->confirm];*)
(*(*v0 as a function of im*)*)


(* ::Input:: *)
(*(*v0 given by unconditional moments*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*(growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"v0"->Function[{t,j,h,k,v,im},Evaluate@uncondE[dc[t]]]]/.uncondE[dc[t]]->0)==(growth[dc,t,"TimeAggregation"->3,"numPeriods"->1])*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*v0(t,i)= v0(t,kh+i) for i=0,1,...,h-2, constant term in expansion should be 0*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*h=1;k=1;*)
(*And@@{*)
(*0===Coefficient[growth[dc,t,"TimeAggregation"->h,"numPeriods"->k,"v0"->Function[{t,j,h,k,v,im},F[t]]]/.dc[__]->dcX,dcX,0]//Simplify*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*h=2;k=1;*)
(*rulej=Table[F[i]->F[h*k+i],{i,0,h-2}];*)
(*And@@{*)
(*0===Coefficient[growth[dc,t,"TimeAggregation"->h,"numPeriods"->k,"v0"->Function[{t,j,h,k,v,im},F[j]]]/.rulej/.dc[__]->dcX,dcX,0]//FullSimplify*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*h=3;k=1;*)
(*rulej=Table[F[i]->F[h*k+i],{i,0,h-2}];*)
(*And@@{*)
(*0===Coefficient[growth[dc,t,"TimeAggregation"->h,"numPeriods"->k,"v0"->Function[{t,j,h,k,v,im},F[j]]]/.rulej/.dc[__]->dcX,dcX,0]//FullSimplify*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*h=4;k=1;*)
(*rulej=Table[F[i]->F[h*k+i],{i,0,h-2}];*)
(*And@@{*)
(*0===Coefficient[(growth[dc,t,"TimeAggregation"->h,"numPeriods"->k,"v0"->Function[{t,j,h,k,v,im},F[j]]])/.rulej/.dc[__]->dcX,dcX,0]//FullSimplify*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*Cases[Expand@growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"Order"->0],coef_. dc[__]^p_.:>p]==={},*)
(*Max@Cases[Expand@growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"Order"->1],coef_. dc[__]^p_.:>p]===1,*)
(*Max@Cases[Expand@growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"Order"->2],coef_. dc[__]^p_.:>p]===2,*)
(*Max@Cases[Expand@growth[dc,t,"TimeAggregation"->3,"numPeriods"->1,"Order"->3],coef_. dc[__]^p_.:>p]===3*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*Cases[Expand@growth[dd,t,i,"TimeAggregation"->3,"numPeriods"->1,"Order"->0],coef_. dd[__,i]^p_.:>p]==={},*)
(*Max@Cases[Expand@growth[dd,t,i,"TimeAggregation"->3,"numPeriods"->1,"Order"->1],coef_. dd[__,i]^p_.:>p]===1,*)
(*Max@Cases[Expand@growth[dd,t,i,"TimeAggregation"->3,"numPeriods"->1,"Order"->2],coef_. dd[__,i]^p_.:>p]===2,*)
(*Max@Cases[Expand@growth[dd,t,i,"TimeAggregation"->3,"numPeriods"->1,"Order"->3],coef_. dd[__,i]^p_.:>p]===3*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*f=FernandoDuarte`LongRunRisk`Tools`TimeAggregation`Private`f;*)
(*g=FernandoDuarte`LongRunRisk`Tools`TimeAggregation`Private`g;*)
(*s=FernandoDuarte`LongRunRisk`Tools`TimeAggregation`Private`s;*)
(*timeSeriesVector=FernandoDuarte`LongRunRisk`Tools`TimeAggregation`Private`timeSeriesVector;*)
(*gt=FernandoDuarte`LongRunRisk`Tools`TimeAggregation`Private`gt;*)
(*True*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*tests gt*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*h=3;k=2;*)
(*And@@{*)
(*gt[dc,t]==dc[t],*)
(*gt[dc,t,{"TimeAggregation"->3,"numPeriods"->k}]==dc[-5+t]+dc[-4+t]+dc[-3+t]+dc[-2+t]+dc[-1+t]+dc[t]-Log[1+E^(-dc[-7+t]-dc[-6+t])+E^-dc[-6+t]]+Log[1+E^(-dc[-1+t]-dc[t])+E^-dc[t]],*)
(*gt[dc,t,"TimeAggregation"->3,"numPeriods"->k]==dc[-5+t]+dc[-4+t]+dc[-3+t]+dc[-2+t]+dc[-1+t]+dc[t]-Log[1+E^(-dc[-7+t]-dc[-6+t])+E^-dc[-6+t]]+Log[1+E^(-dc[-1+t]-dc[t])+E^-dc[t]],*)
(**)
(*gt[dd,t,i,{"TimeAggregation"->3,"numPeriods"->k}]==dd[-5+t,i]+dd[-4+t,i]+dd[-3+t,i]+dd[-2+t,i]+dd[-1+t,i]+dd[t,i]-Log[1+E^(-dd[-7+t,i]-dd[-6+t,i])+E^-dd[-6+t,i]]+Log[1+E^(-dd[-1+t,i]-dd[t,i])+E^-dd[t,i]],*)
(*gt[dd,t,i,"TimeAggregation"->3,"numPeriods"->k]==dd[-5+t,i]+dd[-4+t,i]+dd[-3+t,i]+dd[-2+t,i]+dd[-1+t,i]+dd[t,i]-Log[1+E^(-dd[-7+t,i]-dd[-6+t,i])+E^-dd[-6+t,i]]+Log[1+E^(-dd[-1+t,i]-dd[t,i])+E^-dd[t,i]],*)
(**)
(*gt[dd,t,1,{"TimeAggregation"->3,"numPeriods"->k}]==dd[-5+t,1]+dd[-4+t,1]+dd[-3+t,1]+dd[-2+t,1]+dd[-1+t,1]+dd[t,1]-Log[1+E^(-dd[-7+t,1]-dd[-6+t,1])+E^-dd[-6+t,1]]+Log[1+E^(-dd[-1+t,1]-dd[t,1])+E^-dd[t,1]],*)
(*gt[dd,t,2,"TimeAggregation"->3,"numPeriods"->k]==dd[-5+t,2]+dd[-4+t,2]+dd[-3+t,2]+dd[-2+t,2]+dd[-1+t,2]+dd[t,2]-Log[1+E^(-dd[-7+t,2]-dd[-6+t,2])+E^-dd[-6+t,2]]+Log[1+E^(-dd[-1+t,2]-dd[t,2])+E^-dd[t,2]]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*h=3;k=2;*)
(*And@@{*)
(*gt[dc,t]==dc[t],*)
(*gt[dc,t,"flowVariable"->False]==dc[t],*)
(*gt[dc,t,"TimeAggregation"->3,"flowVariable"->False]==dc[-2+t]+dc[-1+t]+dc[t],*)
(**)
(*gt[dd,t,i,{"numPeriods"->k},"flowVariable"->False]==dd[-1+t,i]+dd[t,i],*)
(*gt[dd,t,i,"flowVariable"->False]==dd[t,i],*)
(**)
(*gt[dd,t,1,{"TimeAggregation"->3},"flowVariable"->False]==dd[-2+t,1]+dd[-1+t,1]+dd[t,1],*)
(*gt[dd,t,2,"flowVariable"->False]==dd[t,2]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*h=3;k=2;*)
(*And@@{*)
(*gt[dc,t]==dc[t],*)
(*gt[dc,t,{"TimeAggregation"->h,"numPeriods"->k},"flowVariable"->False]==dc[-5+t]+dc[-4+t]+dc[-3+t]+dc[-2+t]+dc[-1+t]+dc[t],*)
(*gt[dc,t,"TimeAggregation"->h,"numPeriods"->k,"flowVariable"->False]==dc[-5+t]+dc[-4+t]+dc[-3+t]+dc[-2+t]+dc[-1+t]+dc[t],*)
(**)
(*gt[dd,t,i,{"TimeAggregation"->h,"numPeriods"->k},"flowVariable"->False]==dd[-5+t,i]+dd[-4+t,i]+dd[-3+t,i]+dd[-2+t,i]+dd[-1+t,i]+dd[t,i],*)
(*gt[dd,t,i,"TimeAggregation"->h,"numPeriods"->k,"flowVariable"->False]==dd[-5+t,i]+dd[-4+t,i]+dd[-3+t,i]+dd[-2+t,i]+dd[-1+t,i]+dd[t,i],*)
(**)
(*gt[dd,t,1,{"TimeAggregation"->h,"numPeriods"->k},"flowVariable"->False]==dd[-5+t,1]+dd[-4+t,1]+dd[-3+t,1]+dd[-2+t,1]+dd[-1+t,1]+dd[t,1],*)
(*gt[dd,t,2,"TimeAggregation"->h,"numPeriods"->k,"flowVariable"->False]==dd[-5+t,2]+dd[-4+t,2]+dd[-3+t,2]+dd[-2+t,2]+dd[-1+t,2]+dd[t,2]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*tests g[timeSeriesVector]*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*h=3;k=1;*)
(*And@@{*)
(*g[timeSeriesVector[dc,t,"TimeAggregation"->h],h]==dc[-2+t]+dc[-1+t]+dc[t]-Log[1+E^(-dc[-4+t]-dc[-3+t])+E^-dc[-3+t]]+Log[1+E^(-dc[-1+t]-dc[t])+E^-dc[t]],*)
(*g[timeSeriesVector[dc,t,"numPeriods"->k],1,k]==dc[t],*)
(*g[timeSeriesVector[dc,t,{"TimeAggregation"->h,"numPeriods"->k}],h,k]==dc[-2+t]+dc[-1+t]+dc[t]-Log[1+E^(-dc[-4+t]-dc[-3+t])+E^-dc[-3+t]]+Log[1+E^(-dc[-1+t]-dc[t])+E^-dc[t]],*)
(*g[timeSeriesVector[dc,t,"TimeAggregation"->h,"numPeriods"->k],h,k]==dc[-2+t]+dc[-1+t]+dc[t]-Log[1+E^(-dc[-4+t]-dc[-3+t])+E^-dc[-3+t]]+Log[1+E^(-dc[-1+t]-dc[t])+E^-dc[t]]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*should return unevaluated*)*)
(*(*wrong length for first argument of g*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*h=3;k=1;*)
(*And@@{*)
(*g[timeSeriesVector[dc,t],h]==FernandoDuarte`LongRunRisk`Tools`TimeAggregation`Private`g[{dc[t]},3],*)
(*g[timeSeriesVector[dc,t,"TimeAggregation"->h][[;;-2]],h]==FernandoDuarte`LongRunRisk`Tools`TimeAggregation`Private`g[{dc[t],dc[-1+t],dc[-2+t],dc[-3+t]},3],*)
(*g[timeSeriesVector[dc,t,"numPeriods"->k][[;;-2]],1,k]==FernandoDuarte`LongRunRisk`Tools`TimeAggregation`Private`g[{},1,1],*)
(*g[timeSeriesVector[dc,t,{"TimeAggregation"->h,"numPeriods"->k}][[;;-2]],h,k]==FernandoDuarte`LongRunRisk`Tools`TimeAggregation`Private`g[{dc[t],dc[-1+t],dc[-2+t],dc[-3+t]},3,1],*)
(*g[timeSeriesVector[dc,t,"TimeAggregation"->h,"numPeriods"->k][[;;-2]],h,k]==FernandoDuarte`LongRunRisk`Tools`TimeAggregation`Private`g[{dc[t],dc[-1+t],dc[-2+t],dc[-3+t]},3,1]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*TimeAggregation aggregation and numPeriods for flow variables*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*h=3;k=1;*)
(*And@@{*)
(*g[timeSeriesVector[dc,t,"TimeAggregation"->h],h,"flowVariable"->True]==dc[-2+t]+dc[-1+t]+dc[t]-Log[1+E^(-dc[-4+t]-dc[-3+t])+E^-dc[-3+t]]+Log[1+E^(-dc[-1+t]-dc[t])+E^-dc[t]],*)
(*g[timeSeriesVector[dc,t,"numPeriods"->k],1,k,"flowVariable"->True]==dc[t],*)
(*g[timeSeriesVector[dc,t,{"TimeAggregation"->h,"numPeriods"->k}],h,k,"flowVariable"->True]==dc[-2+t]+dc[-1+t]+dc[t]-Log[1+E^(-dc[-4+t]-dc[-3+t])+E^-dc[-3+t]]+Log[1+E^(-dc[-1+t]-dc[t])+E^-dc[t]],*)
(*g[timeSeriesVector[dc,t,"TimeAggregation"->h,"numPeriods"->k],h,k,"flowVariable"->True]==dc[-2+t]+dc[-1+t]+dc[t]-Log[1+E^(-dc[-4+t]-dc[-3+t])+E^-dc[-3+t]]+Log[1+E^(-dc[-1+t]-dc[t])+E^-dc[t]]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*TimeAggregation aggregation and numPeriods for stock variables*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*h=3;k=1;*)
(*And@@{*)
(*g[timeSeriesVector[dc,t,"TimeAggregation"->h],h,"flowVariable"->False]==dc[-2+t]+dc[-1+t]+dc[t],*)
(*g[timeSeriesVector[dc,t,"numPeriods"->k],1,k,"flowVariable"->False]==dc[t],*)
(*g[timeSeriesVector[dc,t,{"TimeAggregation"->h,"numPeriods"->k}],h,k,"flowVariable"->False]==dc[-2+t]+dc[-1+t]+dc[t],*)
(*g[timeSeriesVector[dc,t,"TimeAggregation"->h,"numPeriods"->k],h,k,"flowVariable"->False]==dc[-2+t]+dc[-1+t]+dc[t]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*h=3;k=1;*)
(*And@@{*)
(*g[timeSeriesVector[dc,t],1,"flowVariable"->False]==dc[t],*)
(*g[timeSeriesVector[dc,t,"TimeAggregation"->h][[;;h*k]],h,"flowVariable"->False]==dc[-2+t]+dc[-1+t]+dc[t],*)
(*g[timeSeriesVector[dc,t,"numPeriods"->k],1,k,"flowVariable"->False]==dc[t],*)
(*g[timeSeriesVector[dc,t,{"TimeAggregation"->h,"numPeriods"->k}][[;;h*k]],h,k,"flowVariable"->False]==dc[-2+t]+dc[-1+t]+dc[t],*)
(*g[timeSeriesVector[dc,t,"TimeAggregation"->h,"numPeriods"->k][[;;h*k]],h,k,"flowVariable"->False]==dc[-2+t]+dc[-1+t]+dc[t]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*should return unevaluated*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*h=3;k=1;*)
(*And@@{*)
(*g[timeSeriesVector[dc,t],"flowVariable"->False]==FernandoDuarte`LongRunRisk`Tools`TimeAggregation`Private`g[{dc[t]},"flowVariable"->False],*)
(*g[timeSeriesVector[dc,t,"TimeAggregation"->h][[;;h*k+1]],h,"flowVariable"->False]==FernandoDuarte`LongRunRisk`Tools`TimeAggregation`Private`g[{dc[t],dc[-1+t],dc[-2+t],dc[-3+t]},3,"flowVariable"->False],*)
(*g[timeSeriesVector[dc,t,{"TimeAggregation"->h,"numPeriods"->k}][[;;h*k+1]],h,k,"flowVariable"->False]==FernandoDuarte`LongRunRisk`Tools`TimeAggregation`Private`g[{dc[t],dc[-1+t],dc[-2+t],dc[-3+t]},3,1,"flowVariable"->False],*)
(*g[timeSeriesVector[dc,t,"TimeAggregation"->h,"numPeriods"->k][[;;h*k+1]],h,k,"flowVariable"->False]==FernandoDuarte`LongRunRisk`Tools`TimeAggregation`Private`g[{dc[t],dc[-1+t],dc[-2+t],dc[-3+t]},3,1,"flowVariable"->False]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*optional values in lists or as separate arguments*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*h=3;k=1;*)
(*And@@{*)
(*g[timeSeriesVector[dd,t,i],1]==dd[t,i],*)
(*g[timeSeriesVector[dd,t,i,"TimeAggregation"->h],h]==dd[-2+t,i]+dd[-1+t,i]+dd[t,i]-Log[1+E^(-dd[-4+t,i]-dd[-3+t,i])+E^-dd[-3+t,i]]+Log[1+E^(-dd[-1+t,i]-dd[t,i])+E^-dd[t,i]],*)
(*g[timeSeriesVector[dd,t,i,"numPeriods"->k],1,k]==dd[t,i],*)
(*g[timeSeriesVector[dd,t,i,{"TimeAggregation"->h,"numPeriods"->k}],h,k]==dd[-2+t,i]+dd[-1+t,i]+dd[t,i]-Log[1+E^(-dd[-4+t,i]-dd[-3+t,i])+E^-dd[-3+t,i]]+Log[1+E^(-dd[-1+t,i]-dd[t,i])+E^-dd[t,i]],*)
(*g[timeSeriesVector[dd,t,i,"TimeAggregation"->h,"numPeriods"->k],h,k]==dd[-2+t,i]+dd[-1+t,i]+dd[t,i]-Log[1+E^(-dd[-4+t,i]-dd[-3+t,i])+E^-dd[-3+t,i]]+Log[1+E^(-dd[-1+t,i]-dd[t,i])+E^-dd[t,i]]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*bond returns*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*h=3;k=1;*)
(*And@@{*)
(*g[timeSeriesVector[bondret,t,m,"TimeAggregation"->h],h]==bondret[-2+t,m]+bondret[-1+t,m]+bondret[t,m]-Log[1+E^(-bondret[-4+t,m]-bondret[-3+t,m])+E^-bondret[-3+t,m]]+Log[1+E^(-bondret[-1+t,m]-bondret[t,m])+E^-bondret[t,m]],*)
(*g[timeSeriesVector[bondret,t,m,"numPeriods"->k],1,k]==bondret[t,m],*)
(*g[timeSeriesVector[bondret,t,m,{"TimeAggregation"->h,"numPeriods"->k}],h,k]==bondret[-2+t,m]+bondret[-1+t,m]+bondret[t,m]-Log[1+E^(-bondret[-4+t,m]-bondret[-3+t,m])+E^-bondret[-3+t,m]]+Log[1+E^(-bondret[-1+t,m]-bondret[t,m])+E^-bondret[t,m]],*)
(*g[timeSeriesVector[bondret,t,m,"TimeAggregation"->h,"numPeriods"->k],h,k]==bondret[-2+t,m]+bondret[-1+t,m]+bondret[t,m]-Log[1+E^(-bondret[-4+t,m]-bondret[-3+t,m])+E^-bondret[-3+t,m]]+Log[1+E^(-bondret[-1+t,m]-bondret[t,m])+E^-bondret[t,m]]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*(*tests timeSeriesVector*)*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*And@@{*)
(*timeSeriesVector[dc,t]=={dc[t]},*)
(*timeSeriesVector[dc,t,"TimeAggregation"->3]=={dc[t],dc[-1+t],dc[-2+t],dc[-3+t],dc[-4+t]},*)
(*timeSeriesVector[dc,t,"numPeriods"->6]=={dc[t],dc[-1+t],dc[-2+t],dc[-3+t],dc[-4+t],dc[-5+t]},*)
(*timeSeriesVector[dc,t,{"TimeAggregation"->12,"numPeriods"->3}]=={dc[t],dc[-1+t],dc[-2+t],dc[-3+t],dc[-4+t],dc[-5+t],dc[-6+t],dc[-7+t],dc[-8+t],dc[-9+t],dc[-10+t],dc[-11+t],dc[-12+t],dc[-13+t],dc[-14+t],dc[-15+t],dc[-16+t],dc[-17+t],dc[-18+t],dc[-19+t],dc[-20+t],dc[-21+t],dc[-22+t],dc[-23+t],dc[-24+t],dc[-25+t],dc[-26+t],dc[-27+t],dc[-28+t],dc[-29+t],dc[-30+t],dc[-31+t],dc[-32+t],dc[-33+t],dc[-34+t],dc[-35+t],dc[-36+t],dc[-37+t],dc[-38+t],dc[-39+t],dc[-40+t],dc[-41+t],dc[-42+t],dc[-43+t],dc[-44+t],dc[-45+t],dc[-46+t]},*)
(*timeSeriesVector[dc,t,"TimeAggregation"->12,"numPeriods"->3]=={dc[t],dc[-1+t],dc[-2+t],dc[-3+t],dc[-4+t],dc[-5+t],dc[-6+t],dc[-7+t],dc[-8+t],dc[-9+t],dc[-10+t],dc[-11+t],dc[-12+t],dc[-13+t],dc[-14+t],dc[-15+t],dc[-16+t],dc[-17+t],dc[-18+t],dc[-19+t],dc[-20+t],dc[-21+t],dc[-22+t],dc[-23+t],dc[-24+t],dc[-25+t],dc[-26+t],dc[-27+t],dc[-28+t],dc[-29+t],dc[-30+t],dc[-31+t],dc[-32+t],dc[-33+t],dc[-34+t],dc[-35+t],dc[-36+t],dc[-37+t],dc[-38+t],dc[-39+t],dc[-40+t],dc[-41+t],dc[-42+t],dc[-43+t],dc[-44+t],dc[-45+t],dc[-46+t]}*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*On[General::stop];*)
(*True*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*End[];*)


(* ::Input:: *)
(*addBeginEnd[testFilePath,testContext];*)
(*{*)
(*tr[Evaluate@name]["TestReport"] ,*)
(*tr[Evaluate@name]["ActualOutput"] ,*)
(*tr[Evaluate@name]["ExpectedOutput"] ,*)
(*tr[Evaluate@name]["OutputTrueQ"]*)
(*}=runTests[testFilePath];*)
(*(*tableActualVsExpeected[testName_String];*)*)
(*cleanUp[];*)


(* ::Section:: *)
(*Tools`ToNumber`*)


(* ::Input:: *)
(*name = First@NotebookRead[PreviousCell[CellStyle -> "Section"]];*)
(*makeDefinitions[name];*)


(* ::Input:: *)
(*Begin[Evaluate@testContext];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*longTest = False; (*fast and partial coverage (False) or slow and full coverage (True)*)*)
(*True*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*With[{context=context},*)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Needs@context;*)
(*$ContextPath = DeleteDuplicates@Prepend[$ContextPath,"FernandoDuarte`LongRunRisk`Tools`ToNumber`Private`"];*)
(*True*)
(*,"ConfirmResults"->confirm];*)
(*];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Off[General::stop];*)
(*Off[FindRoot::lstol];*)
(**)
(*Needs["FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeUnconditionalExpectations`"];*)
(*Needs["FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeConditionalExpectations`"];*)
(*Needs["FernandoDuarte`LongRunRisk`Model`EndogenousEq`"];*)
(*Needs["FernandoDuarte`LongRunRisk`Model`ExogenousEq`"];*)
(*Needs["FernandoDuarte`LongRunRisk`Tools`TimeAggregation`"];*)
(*Needs["FernandoDuarte`LongRunRisk`ComputationalEngine`SolveEulerEq`"];*)
(**)
(*Get@Get[FileNameJoin[{"FernandoDuarte/LongRunRisk","Models.wl"}]] ;*)
(*msp=FernandoDuarte`LongRunRisk`Models;*)
(*modBY=msp["BY"];*)
(*modBKY=msp["BKY"];*)
(*modNRC=msp["NRC"];*)
(*modDES=msp["DES"];*)
(*modNRCStochVol=msp["NRCStochVol"];*)
(*mods=If[longTest,*)
(*{modBY,modBKY,modNRC,modDES,modNRCStochVol},*)
(*{modBKY}*)
(*];*)
(**)
(*(*define expressions to test*)*)
(*expr[t_,m_,i_,mu_]:={wc[t],pd[t,i],bond[t,m],nombond[t,m],bondexcret[t,m],bondfw[t,m],bondfwspread[t,m],bondret[t,m],bondyield[t,m],excretc[t],excret[t,i],kappa0[mu],kappa1[mu],nombondexcret[t,m],nombondfw[t,m],nombondfwspread[t,m],nombondret[t,m],nombondyield[t,m],nomrf[t],nomsdf[t],retc[t],ret[t,i],rf[t],sdf[t],pi[t],dc[t],growth[dc,t,"TimeAggregation"->2,"numPeriods"->1],growth[dd,t,1,"TimeAggregation"->2],*)
(*AA dc[t+1]excret[t,1],AA excret[t,1]+BB nombondyield[t,2]};*)
(*ee=expr[t,3,1,1];*)
(*e1=ee[[1;;3]];*)
(**)
(*(*define expression e2 and list opts to test options*)*)
(*e2=ee[[1;;2]];*)
(*optsList={*)
(*{},*)
(*{maxMaturity->6},*)
(*{"FindRootOptions"->{MaxIterations->100}},*)
(*{MaxIterations->100},*)
(*{"initialGuess" -> <|"Ewc"->{4},"Epd"->{{4}}|>},*)
(*{"initialGuess" -> <|"Ewc"->{4},"Epd"->{{4}}|>,MaxIterations->100},*)
(*{"initialGuess" -> <|"Ewc"->{4},"Epd"->{{4}}|>,"FindRootOptions"->{MaxIterations->100}},*)
(*{maxMaturity->6,"initialGuess" -> <|"Ewc"->{4},"Epd"->{{4}}|>,MaxIterations->100},*)
(*{"PrintResidualsNorm"->True},*)
(*{"CheckResiduals"->True,"Tol"->1},*)
(*{"CheckResiduals"->True,"Tol"->10.^-20},*)
(*{"PrintResidualsNorm"->True,maxMaturity->6,"initialGuess" -> <|"Ewc"->{4},"Epd"->{{4}}|>,MaxIterations->100},*)
(*{"RecurrenceTableOptions"->{"DependentVariables"->Automatic}},*)
(*{DependentVariables->Automatic}*)
(*};*)
(*opts=If[longTest,optsList[[1;;5]],optsList[[1;;2]]];*)
(*(*define list of parameters, guess, options, expr, to test passing new parameters*)*)
(*newParameters={delta->0.99};*)
(*guessCoeffsSolution={A[0]->4.6};*)
(*optNewParam={"initialGuess" -> <|"Ewc"->{4},"Epd"->{{4}}|>,MaxIterations->100};*)
(*exprNewParam = uncondE[wc[t]];*)
(**)
(*AbortProtect[*)
(*Do[*)
(*(*counter for Do loop*)*)
(*ind=0;*)
(*(*rules to evaluate numerically at arbitrarily chosen values*)*)
(*stateVars=#[_]&/@DeleteDuplicates[DeleteCases[Cases[Variables[model["stateVars"][t] ],x_[_]:>x],0]];*)
(*numModel=Join[Thread[stateVars->1.],{FernandoDuarte`LongRunRisk`Model`Shocks`eps[_][_]->1,FernandoDuarte`LongRunRisk`Model`Shocks`eps[_][_,_]->1.,mu->2.,AA->-1.,BB->3.}];*)
(**)
(*(*local definitions*)*)
(*FernandoDuarte`LongRunRisk`Tests`Tools`ToNumber`toNum=FernandoDuarte`LongRunRisk`Tools`ToNumber`toNum;*)
(*FernandoDuarte`LongRunRisk`Tests`Tools`ToNumber`toEquation=FernandoDuarte`LongRunRisk`Tools`ToNumber`toEquation;*)
(*FernandoDuarte`LongRunRisk`Tests`Tools`ToNumber`toExogenousVars=FernandoDuarte`LongRunRisk`Tools`ToNumber`toExogenousVars;*)
(*FernandoDuarte`LongRunRisk`Tests`Tools`ToNumber`toStateVars=FernandoDuarte`LongRunRisk`Tools`ToNumber`toStateVars;*)
(*FernandoDuarte`LongRunRisk`Tests`Tools`ToNumber`processNewParameters=FernandoDuarte`LongRunRisk`Tools`ToNumber`processNewParameters;*)
(**)
(*FernandoDuarte`LongRunRisk`Tests`Tools`ToNumber`uncondE=FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeUnconditionalExpectations`uncondE;*)
(*FernandoDuarte`LongRunRisk`Tests`Tools`ToNumber`uncondVar=FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeUnconditionalExpectations`uncondVar;*)
(*FernandoDuarte`LongRunRisk`Tests`Tools`ToNumber`uncondCov=FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeUnconditionalExpectations`uncondCov;*)
(*FernandoDuarte`LongRunRisk`Tests`Tools`ToNumber`uncondCorr=FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeUnconditionalExpectations`uncondCorr;*)
(**)
(*FernandoDuarte`LongRunRisk`Tests`Tools`ToNumber`ev=FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeConditionalExpectations`ev;*)
(*FernandoDuarte`LongRunRisk`Tests`Tools`ToNumber`var=FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeConditionalExpectations`var;*)
(*FernandoDuarte`LongRunRisk`Tests`Tools`ToNumber`cov=FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeConditionalExpectations`cov;*)
(*FernandoDuarte`LongRunRisk`Tests`Tools`ToNumber`corr=FernandoDuarte`LongRunRisk`ComputationalEngine`ComputeConditionalExpectations`corr;*)
(*(**********toNum**********)*)
(**)
(*(*toNum[model]*)*)
(*tn=toNum[model];*)
(*outTests[model["shortname"]][ind]=And@@( *)
(*Flatten@{*)
(*Head@tn===Function,*)
(*NumericQ/@( *)
(*Flatten@*)
(*If[longTest,*)
(*{*)
(*((e1//tn)//.numModel),*)
(*(((uncondE/@e1)//tn)//.numModel),*)
(*(((uncondVar/@e1)//tn)//.numModel),*)
(*((MapThread[uncondCov[#1,#2]&,{e1,Reverse@e1}]//tn)//.numModel),*)
(*((MapThread[uncondCorr[#1,#2]&,{e1[[1;;2]],e1[[-2;;-1]]}]//tn)//.numModel),*)
(*(((ev[#,t-1]&/@e1)//tn)//.numModel),*)
(*(((var[#,t-1]&/@e1)//tn)//.numModel),*)
(*((MapThread[cov[#1,#2,t-1]&,{e1,Reverse@e1}]//tn)//.numModel),*)
(*((MapThread[corr[#1,#2,t-1]&,{e1[[1;;2]],e1[[-2;;-1]]}]//tn)//.numModel)*)
(*}*)
(*,*)
(*{*)
(*((e1//tn)//.numModel),*)
(*(((uncondE/@e1)//tn)//.numModel),*)
(*(((uncondVar/@e1)//tn)//.numModel),*)
(*(((ev[#,t-1]&/@e1)//tn)//.numModel),*)
(*(((var[#,t-1]&/@e1)//tn)//.numModel)*)
(*}*)
(*]*)
(*)*)
(*}*)
(*);*)
(*ind=ind+1;*)
(**)
(*(*toNum[expression, model]*)*)
(*outTests[model["shortname"]][ind]=And@@( *)
(*Flatten@{*)
(*Head@tn===Function,*)
(*NumericQ/@( *)
(*Flatten@*)
(*If[longTest,*)
(*{*)
(*((toNum[e1,model] )//.numModel),*)
(*(((toNum[uncondE/@e1,model]) )//.numModel),*)
(*(((toNum[uncondVar/@e1,model]) )//.numModel),*)
(*((toNum[MapThread[uncondCov[#1,#2]&,{e1,Reverse@e1}] ,model])//.numModel),*)
(*((toNum[MapThread[uncondCorr[#1,#2]&,{e1[[1;;2]],e1[[-2;;-1]]}],model] )//.numModel),*)
(*(((toNum[ev[#,t-1]&/@e1,model]) )//.numModel),*)
(*(((toNum[var[#,t-1]&/@e1,model]) )//.numModel),*)
(*((toNum[MapThread[cov[#1,#2,t-1]&,{e1,Reverse@e1}],model] )//.numModel),*)
(*((toNum[MapThread[corr[#1,#2,t-1]&,{e1[[1;;2]],e1[[-2;;-1]]}],model] )//.numModel)*)
(*}*)
(*,*)
(*{*)
(*((toNum[e1,model] )//.numModel),*)
(*(((toNum[uncondE/@e1,model]) )//.numModel),*)
(*(((toNum[uncondVar/@e1,model]) )//.numModel),*)
(*(((toNum[ev[#,t-1]&/@e1,model]) )//.numModel),*)
(*(((toNum[var[#,t-1]&/@e1,model]) )//.numModel)*)
(*}*)
(*]*)
(*)*)
(*}*)
(*);*)
(*ind=ind+1;*)
(**)
(*(*toNum["Rules", model]*)*)
(*outTests[model["shortname"]][ind]=And@@( *)
(*Flatten@{*)
(*Head@tn===Function,*)
(*NumericQ/@( *)
(*Flatten@*)
(*If[longTest,*)
(*{*)
(*((toEquation[e1,model] )//.numModel),*)
(*(((toEquation[uncondE/@e1,model]) )//.numModel),*)
(*(((toEquation[uncondVar/@e1,model]) )//.numModel),*)
(*((toEquation[MapThread[uncondCov[#1,#2]&,{e1,Reverse@e1}] ,model])//.numModel),*)
(*((toEquation[MapThread[uncondCorr[#1,#2]&,{e1[[1;;2]],e1[[-2;;-1]]}],model] )//.numModel),*)
(*(((toEquation[ev[#,t-1]&/@e1,model]) )//.numModel),*)
(*(((toEquation[var[#,t-1]&/@e1,model]) )//.numModel),*)
(*((toEquation[MapThread[cov[#1,#2,t-1]&,{e1,Reverse@e1}],model] )//.numModel),*)
(*((toEquation[MapThread[corr[#1,#2,t-1]&,{e1[[1;;2]],e1[[-2;;-1]]}],model] )//.numModel)*)
(*}*)
(*,*)
(*{*)
(*((toEquation[e1,model] )//.numModel),*)
(*(((toEquation[uncondE/@e1,model]) )//.numModel),*)
(*(((toEquation[uncondVar/@e1,model]) )//.numModel),*)
(*(((toEquation[ev[#,t-1]&/@e1,model]) )//.numModel),*)
(*(((toEquation[var[#,t-1]&/@e1,model]) )//.numModel)*)
(*}*)
(*]//.toNum["Rules",model]*)
(*)*)
(*}*)
(*);*)
(*ind=ind+1;*)
(**)
(*(**********options for toNum**********)*)
(*Do[*)
(*(*toNum[model]*)*)
(*tn=toNum[model,Sequence@@opt];*)
(*outTests[model["shortname"]][ind]=And@@( *)
(*Flatten@{*)
(*Head@tn===Function,*)
(*NumericQ/@( *)
(*Flatten@*)
(*If[longTest,*)
(*{*)
(*((e2//tn)//.numModel),*)
(*(((uncondE/@e2)//tn)//.numModel),*)
(*(((uncondVar/@e2)//tn)//.numModel),*)
(*((MapThread[uncondCov[#1,#2]&,{e2,Reverse@e2}]//tn)//.numModel),*)
(*((MapThread[uncondCorr[#1,#2]&,{e2[[1;;2]],e2[[-2;;-1]]}]//tn)//.numModel),*)
(*(((ev[#,t-1]&/@e2)//tn)//.numModel),*)
(*(((var[#,t-1]&/@e2)//tn)//.numModel),*)
(*((MapThread[cov[#1,#2,t-1]&,{e2,Reverse@e2}]//tn)//.numModel),*)
(*((MapThread[corr[#1,#2,t-1]&,{e2[[1;;2]],e2[[-2;;-1]]}]//tn)//.numModel)*)
(*}*)
(*,*)
(*{*)
(*((e2//tn)//.numModel),*)
(*(((uncondE/@e2)//tn)//.numModel),*)
(*(((uncondVar/@e2)//tn)//.numModel),*)
(*(((ev[#,t-1]&/@e2)//tn)//.numModel),*)
(*(((var[#,t-1]&/@e2)//tn)//.numModel)*)
(*}*)
(*]*)
(*)*)
(*}*)
(*);*)
(*ind=ind+1;*)
(**)
(*(*toNum[expression, model]*)*)
(*outTests[model["shortname"]][ind]=And@@( *)
(*Flatten@{*)
(*Head@tn===Function,*)
(*NumericQ/@( *)
(*Flatten@*)
(*If[longTest,*)
(*{*)
(*((toNum[e2,model,Sequence@@opt] )//.numModel),*)
(*(((toNum[uncondE/@e2,model,Sequence@@opt]) )//.numModel),*)
(*(((toNum[uncondVar/@e2,model,Sequence@@opt]) )//.numModel),*)
(*((toNum[MapThread[uncondCov[#1,#2]&,{e2,Reverse@e2}] ,model,Sequence@@opt])//.numModel),*)
(*((toNum[MapThread[uncondCorr[#1,#2]&,{e2[[1;;2]],e2[[-2;;-1]]}],model,Sequence@@opt] )//.numModel),*)
(*(((toNum[ev[#,t-1]&/@e2,model,Sequence@@opt]) )//.numModel),*)
(*(((toNum[var[#,t-1]&/@e2,model,Sequence@@opt]) )//.numModel),*)
(*((toNum[MapThread[cov[#1,#2,t-1]&,{e2,Reverse@e2}],model,Sequence@@opt] )//.numModel),*)
(*((toNum[MapThread[corr[#1,#2,t-1]&,{e2[[1;;2]],e2[[-2;;-1]]}],model,Sequence@@opt] )//.numModel)*)
(*}*)
(*,*)
(*{*)
(*((toNum[e2,model,Sequence@@opt] )//.numModel),*)
(*(((toNum[uncondE/@e2,model,Sequence@@opt]) )//.numModel),*)
(*(((toNum[uncondVar/@e2,model,Sequence@@opt]) )//.numModel),*)
(*(((toNum[ev[#,t-1]&/@e2,model,Sequence@@opt]) )//.numModel),*)
(*(((toNum[var[#,t-1]&/@e2,model,Sequence@@opt]) )//.numModel)*)
(*}*)
(*]*)
(*)*)
(*}*)
(*);*)
(*ind=ind+1;*)
(**)
(*(*toNum["Rules", model]*)*)
(*outTests[model["shortname"]][ind]=And@@( *)
(*Flatten@{*)
(*Head@tn===Function,*)
(*NumericQ/@( *)
(*Flatten@*)
(*If[longTest,*)
(*{*)
(*((toEquation[e2,model] )//.numModel),*)
(*(((toEquation[uncondE/@e2,model]) )//.numModel),*)
(*(((toEquation[uncondVar/@e2,model]) )//.numModel),*)
(*((toEquation[MapThread[uncondCov[#1,#2]&,{e2,Reverse@e2}] ,model])//.numModel),*)
(*((toEquation[MapThread[uncondCorr[#1,#2]&,{e2[[1;;2]],e2[[-2;;-1]]}],model] )//.numModel),*)
(*(((toEquation[ev[#,t-1]&/@e2,model]) )//.numModel),*)
(*(((toEquation[var[#,t-1]&/@e2,model]) )//.numModel),*)
(*((toEquation[MapThread[cov[#1,#2,t-1]&,{e2,Reverse@e2}],model] )//.numModel),*)
(*((toEquation[MapThread[corr[#1,#2,t-1]&,{e2[[1;;2]],e2[[-2;;-1]]}],model] )//.numModel)*)
(*}*)
(*,*)
(*{*)
(*((toEquation[e2,model] )//.numModel),*)
(*(((toEquation[uncondE/@e2,model]) )//.numModel),*)
(*(((toEquation[uncondVar/@e2,model]) )//.numModel),*)
(*(((toEquation[ev[#,t-1]&/@e2,model]) )//.numModel),*)
(*(((toEquation[var[#,t-1]&/@e2,model]) )//.numModel)*)
(*}*)
(*]//.toNum["Rules",model,Sequence@@opt]*)
(*)*)
(*}*)
(*);*)
(*ind=ind+1;*)
(*,*)
(*{opt,opts}*)
(*];*)
(**)
(*(*"UpdatePd", "UpdateBond", "UpdateNomBond", "UpdateBonds" are ignored, toNum always uses "UpdatePd"->True,"UpdateBonds"->True*)*)
(*outTests[model["shortname"]][ind]=And@@( *)
(*NumericQ/@( *)
(*Flatten@{*)
(*pd[t,1]//toNum[model,"UpdatePd"->False]//.numModel,*)
(*toNum[pd[t,1],model,"UpdatePd"->False]//.numModel,*)
(*toEquation[pd[t,1],model]//.toNum["Rules",model,"UpdatePd"->False]//.numModel,*)
(**)
(*{bondyield[t,2],nombondyield[t,3]}//toNum[model,"UpdateBonds"->False]//.numModel,*)
(*toNum[{bondyield[t,2],nombondyield[t,3]},model,"UpdateBonds"->False]//.numModel,*)
(*toEquation[{bondyield[t,2],nombondyield[t,3]},model]//.toNum["Rules",model,"UpdateBonds"->False]//.numModel*)
(*}*)
(*)*)
(*);*)
(*ind=ind+1;*)
(**)
(*(**********new parameters, guess for toNum**********)*)
(*outTests[model["shortname"]][ind]=And@@( *)
(*NumericQ/@{*)
(*(*pass new parameters*)*)
(*exprNewParam//toNum[model,newParameters]//.numModel,*)
(*toNum[exprNewParam,model,newParameters]//.numModel,*)
(*toEquation[exprNewParam,model]//.toNum["Rules",model,newParameters]//.numModel,*)
(**)
(*(*pass guess*)*)
(*exprNewParam//toNum[model,{},guessCoeffsSolution]//.numModel,*)
(*toNum[exprNewParam,model,{},guessCoeffsSolution]//.numModel,*)
(*toEquation[exprNewParam,model]//.toNum["Rules",model,{},guessCoeffsSolution]//.numModel,*)
(**)
(*(*pass new parameters and guess*)*)
(*exprNewParam//toNum[model,newParameters,guessCoeffsSolution]//.numModel,*)
(*toNum[exprNewParam,model,newParameters,guessCoeffsSolution]//.numModel,*)
(*toEquation[exprNewParam,model]//.toNum["Rules",model,newParameters,guessCoeffsSolution]//.numModel,*)
(**)
(*(*new parameters, guess, and options*)*)
(*exprNewParam//toNum[model,newParameters,Sequence@@optNewParam]//.numModel,*)
(*toNum[exprNewParam,model,newParameters,Sequence@@optNewParam]//.numModel,*)
(*toEquation[exprNewParam,model]//.toNum["Rules",model,newParameters,Sequence@@optNewParam]//.numModel,*)
(**)
(*exprNewParam//toNum[model,{},guessCoeffsSolution,Sequence@@optNewParam]//.numModel,*)
(*toNum[exprNewParam,model,{},guessCoeffsSolution,Sequence@@optNewParam]//.numModel,*)
(*toEquation[exprNewParam,model]//.toNum["Rules",model,{},guessCoeffsSolution,Sequence@@optNewParam]//.numModel,*)
(**)
(*exprNewParam//toNum[model,newParameters,guessCoeffsSolution,Sequence@@optNewParam]//.numModel,*)
(*toNum[exprNewParam,model,newParameters,guessCoeffsSolution,Sequence@@optNewParam]//.numModel,*)
(*toEquation[exprNewParam,model]//.toNum["Rules",model,newParameters,guessCoeffsSolution,Sequence@@optNewParam]//.numModel*)
(*}*)
(*);*)
(*ind=ind+1;*)
(*,*)
(*{model,mods}*)
(*];*)
(*];*)
(**)
(*noMissingTest={};*)
(*Do[*)
(*testNumber=*)
(*Sort@Cases[Keys@SubValues@outTests,Verbatim[HoldPattern][outTests[model["shortname"]][i_Integer]]:>i];*)
(*AppendTo[noMissingTest,Range[0,Max[testNumber]]==testNumber];*)
(*,*)
(*{model,mods}*)
(*];*)
(**)
(*out=And@@( *)
(*Flatten@{*)
(*And@@noMissingTest,*)
(*And@@Values@SubValues@outTests*)
(*}*)
(*);*)
(*On[General::stop];*)
(*Off[FindRoot::lstol];*)
(**)
(*out*)
(**)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*FernandoDuarte`LongRunRisk`Tests`Tools`ToNumber`processNewParameters=FernandoDuarte`LongRunRisk`Tools`ToNumber`processNewParameters;*)
(*(*helper functions*)*)
(*(*returns True if evaluation of expr returns $Aborted*)*)
(*SetAttributes[checkAbrt,HoldAll];*)
(*checkAbrt[expr_]:=TrueQ@Quiet[*)
(*AbortProtect[*)
(*CheckAbort[expr,True]*)
(*]*)
(*];*)
(*(*returns True if msg issued when expr is evaluated*)*)
(*SetAttributes[checkMsg,HoldAll];*)
(*checkMsg[expr_,msg_]:=*)
(*CheckAbort[*)
(*Quiet[*)
(*AbortProtect[*)
(*c=Check[expr;,True,msg];*)
(*];*)
(*];*)
(*TrueQ@c*)
(*,*)
(*TrueQ@c*)
(*];*)
(**)
(*(*old and new parameters are equal*)*)
(*(*define old and new parameters*)*)
(*p={delta->0.998`,Esx->0.0078`,gamma->10,muc->0.0015`,phisxs->2.3`*^-6,phix->0.044`,psi->1.5`,rhox->0.979`,theta->(1-gamma)/(1-1/psi),vx->0.987`,mud[1]->0.0015`,phidxd[1]->4.5`,rhodx[1]->3};*)
(*newP={delta->0.998`,Esx->0.0078`,gamma->10,muc->0.0015`,phisxs->2.3`*^-6,phix->0.044`,psi->1.5`,rhox->0.979`,theta->(1-gamma)/(1-1/psi),vx->0.987`,mud[1]->0.0015`,phidxd[1]->4.5`,rhodx[1]->3};*)
(*(*evaluate all parameters numerically*)*)
(*pn=KeyValueMap[(#1->(#2/.p))&,Association@p];*)
(*newPn=KeyValueMap[(#1->(#2/.newP))&,Association@newP];*)
(**)
(*(*process parameters*)*)
(*procP=processNewParameters[newP,p];*)
(*procPn=processNewParameters[newPn,pn];*)
(*procPn1=processNewParameters[newP,pn];*)
(*procPn2=processNewParameters[newPn,p];*)
(**)
(*(*capture messages*)*)
(*msg=Block[*)
(*{$MessagePrePrint=Sow,$MessageList={}},*)
(*Reap[Module[{},processNewParameters[newP,p];];$MessageList]*)
(*];*)
(**)
(*And@@{*)
(*(*symbolic and numeric parameters give same answer*)*)
(*Sort@procP===Sort@procPn===Sort@procPn1===Sort@procPn2,*)
(*(*values are numbers*)*)
(*And@@(NumberQ/@Values@procP),*)
(*(*parameters in processed list are same as in new parameters*)*)
(*(Sort@Keys@procP)===(Sort@Keys@newP),*)
(*(*parameters in processed list are subset of old parameters*)*)
(*SubsetQ[Keys@p,Keys@procP],*)
(*(*no message issued*)*)
(*ReleaseHold@msg=={{},{}},*)
(*(*not aborted*)*)
(*Not@checkAbrt[processNewParameters[newP,p]]*)
(*}*)
(**)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*new parameters are subset of old parameters*)*)
(**)
(*(*define old and new parameters*)*)
(*p={delta->0.998`,Esx->0.0078`,gamma->10,muc->0.0015`,phisxs->2.3`*^-6,phix->0.044`,psi->1.5`,rhox->0.979`,theta->(1-gamma)/(1-1/psi),vx->0.987`,mud[1]->0.0015`,phidxd[1]->4.5`,rhodx[1]->3};*)
(*newP={delta->0.9,Esx->1};*)
(*(*evaluate all parameters numerically*)*)
(*pn=KeyValueMap[(#1->(#2/.p))&,Association@p];*)
(*newPn=KeyValueMap[(#1->(#2/.newP))&,Association@newP];*)
(**)
(*(*process parameters*)*)
(*procP=processNewParameters[newP,p];*)
(*procPn=processNewParameters[newPn,pn];*)
(*procPn1=processNewParameters[newP,pn];*)
(*procPn2=processNewParameters[newPn,p];*)
(**)
(*(*capture messages*)*)
(*msg=Block[*)
(*{$MessagePrePrint=Sow,$MessageList={}},*)
(*Reap[Module[{},processNewParameters[newP,p];];$MessageList]*)
(*];*)
(**)
(*And@@{*)
(*(*symbolic and numeric parameters give same answer*)*)
(*Sort@procP===Sort@procPn===Sort@procPn1===Sort@procPn2,*)
(*(*values are numbers*)*)
(*And@@(NumberQ/@Values@procP),*)
(*(*parameters in processed list are same as in new parameters*)*)
(*Sort@Keys@procP===Sort@Keys@newP,*)
(*(*parameters in processed list are subset of old parameters*)*)
(*SubsetQ[Keys@p,Keys@procP],*)
(*(*no message issued*)*)
(*ReleaseHold@msg=={{},{}},*)
(*(*not aborted*)*)
(*Not@checkAbrt[processNewParameters[newP,p]]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*new parameters is empty*)*)
(*(*define old and new parameters*)*)
(*p={delta->0.998`,Esx->0.0078`,gamma->10,muc->0.0015`,phisxs->2.3`*^-6,phix->0.044`,psi->1.5`,rhox->0.979`,theta->(1-gamma)/(1-1/psi),vx->0.987`,mud[1]->0.0015`,phidxd[1]->4.5`,rhodx[1]->3};*)
(*newP={};*)
(*(*evaluate all parameters numerically*)*)
(*pn=KeyValueMap[(#1->(#2/.p))&,Association@p];*)
(*newPn=KeyValueMap[(#1->(#2/.newP))&,Association@newP];*)
(**)
(*(*process parameters*)*)
(*procP=processNewParameters[newP,p];*)
(*procPn=processNewParameters[newPn,pn];*)
(*procPn1=processNewParameters[newP,pn];*)
(*procPn2=processNewParameters[newPn,p];*)
(**)
(*(*capture messages*)*)
(*msg=Block[*)
(*{$MessagePrePrint=Sow,$MessageList={}},*)
(*Reap[Module[{},processNewParameters[newP,p];];$MessageList]*)
(*];*)
(**)
(*And@@{*)
(*(*symbolic and numeric parameters give same answer*)*)
(*Sort@procP===Sort@procPn===Sort@procPn1===Sort@procPn2,*)
(*(*values are numbers*)*)
(*And@@(NumberQ/@Values@procP),*)
(*(*parameters in processed list are same as in new parameters*)*)
(*Sort@Keys@procP===Sort@Keys@newP,*)
(*(*parameters in processed list are subset of old parameters*)*)
(*SubsetQ[Keys@p,Keys@procP],*)
(*(*no message issued*)*)
(*ReleaseHold@msg=={{},{}},*)
(*(*not aborted*)*)
(*Not@checkAbrt[processNewParameters[newP,p]]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*new parameters are not a subset of old parameters*)*)
(*(*define old and new parameters*)*)
(*p={delta->0.998`,Esx->0.0078`,gamma->10,muc->0.0015`,phisxs->2.3`*^-6,phix->0.044`,psi->1.5`,rhox->0.979`,theta->(1-gamma)/(1-1/psi),vx->0.987`,mud[1]->0.0015`,phidxd[1]->4.5`,rhodx[1]->3};*)
(*newP={delta->0.9,Esx->1,phip->3};*)
(**)
(*And@@{*)
(*(*aborts*)*)
(*checkAbrt[processNewParameters[newP,p]],*)
(*(*with message subsetparam*)*)
(*checkMsg[processNewParameters[newP,p],FernandoDuarte`LongRunRisk`Tools`ToNumber`processNewParameters::subsetparam]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*psi=1 in new parameters aborts*)*)
(*(*define old and new parameters*)*)
(*p={delta->0.998`,Esx->0.0078`,gamma->10,muc->0.0015`,phisxs->2.3`*^-6,phix->0.044`,psi->1.5`,rhox->0.979`,theta->(1-gamma)/(1-1/psi),vx->0.987`,mud[1]->0.0015`,phidxd[1]->4.5`,rhodx[1]->3};*)
(*newP={delta->0.9,Esx->1,psi->1};*)
(*And@@{*)
(*(*aborts*)*)
(*checkAbrt[processNewParameters[newP,p]],*)
(*(*with message subsetparam*)*)
(*checkMsg[processNewParameters[newP,p],FernandoDuarte`LongRunRisk`Tools`ToNumber`processNewParameters::psi]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*psi=1. in new parameters aborts*)*)
(*(*define old and new parameters*)*)
(*p={delta->0.998`,Esx->0.0078`,gamma->10,muc->0.0015`,phisxs->2.3`*^-6,phix->0.044`,psi->1.5`,rhox->0.979`,theta->(1-gamma)/(1-1/psi),vx->0.987`,mud[1]->0.0015`,phidxd[1]->4.5`,rhodx[1]->3};*)
(*newP={delta->0.9,Esx->1,psi->1.};*)
(*And@@{*)
(*(*aborts*)*)
(*checkAbrt[processNewParameters[newP,p]],*)
(*(*with message subsetparam*)*)
(*checkMsg[processNewParameters[newP,p],FernandoDuarte`LongRunRisk`Tools`ToNumber`processNewParameters::psi]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*gamma, psi, theta relate by theta=(1-gamma)/(1-1/psi)*)*)
(*(*when gamma, psi, theta all provided, ignore theta and issue message unless theta is exactly (1-gamma)/(1-1/psi)*)*)
(*(*case: theta is exactly (1-gamma)/(1-1/psi)*)*)
(*p={delta->0.998`,Esx->0.0078`,gamma->10,muc->0.0015`,phisxs->2.3`*^-6,phix->0.044`,psi->1.5`,rhox->0.979`,theta->(1-gamma)/(1-1/psi),vx->0.987`,mud[1]->0.0015`,phidxd[1]->4.5`,rhodx[1]->3};*)
(*newP={gamma->10,theta->(1-gamma)/(1-1/psi),psi->1.5`};*)
(*procP=processNewParameters[newP,p];*)
(*(*capture messages*)*)
(*msg=Block[{$MessagePrePrint=Sow,$MessageList={}},Reap[Module[{},processNewParameters[newP,p];];$MessageList]];*)
(*And@@{*)
(*(*values are numbers*)*)
(*And@@(NumberQ/@Values@procP),*)
(*(*parameters in processed list are same as in new parameters*)*)
(*Sort@Keys@procP===Sort@Keys@newP,*)
(*(*parameters in processed list are subset of old parameters*)*)
(*SubsetQ[Keys@p,Keys@procP],*)
(*(*no message issued*)*)
(*ReleaseHold@msg=={{},{}},*)
(*(*not aborted*)*)
(*Not@checkAbrt[processNewParameters[newP,p]]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*case: theta is not exactly (1-gamma)/(1-1/psi)*)*)
(*p={delta->0.998`,Esx->0.0078`,gamma->10,muc->0.0015`,phisxs->2.3`*^-6,phix->0.044`,psi->1.5`,rhox->0.979`,theta->(1-gamma)/(1-1/psi),vx->0.987`,mud[1]->0.0015`,phidxd[1]->4.5`,rhodx[1]->3};*)
(*newP={gamma->10,theta->3.23`,psi->1.5`};*)
(*procP=Quiet[processNewParameters[newP,p],FernandoDuarte`LongRunRisk`Tools`ToNumber`processNewParameters::param];*)
(*And@@{*)
(*(*values are numbers*)*)
(*And@@(NumberQ/@Values@procP),*)
(*(*parameters in processed list are same as in new parameters*)*)
(*Sort@Keys@procP===Sort@Keys@newP,*)
(*(*parameters in processed list are subset of old parameters*)*)
(*SubsetQ[Keys@p,Keys@procP],*)
(*(*not aborted*)*)
(*Not@checkAbrt[processNewParameters[newP,p]],*)
(*(*with message subsetparam*)*)
(*checkMsg[processNewParameters[newP,p],FernandoDuarte`LongRunRisk`Tools`ToNumber`processNewParameters::param],*)
(*(*theta has correct value*)*)
(*Chop@RealAbs[(theta/.procP)-(-27.)]<$MachineEpsilon*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*when 2 of {gamma, psi, theta} are provided, solve for the third and add to newParameters*)*)
(*(*{psi, theta}*)*)
(*p={delta->0.998`,Esx->0.0078`,gamma->10,muc->0.0015`,phisxs->2.3`*^-6,phix->0.044`,psi->1.5`,rhox->0.979`,theta->(1-gamma)/(1-1/psi),vx->0.987`,mud[1]->0.0015`,phidxd[1]->4.5`,rhodx[1]->3};*)
(*newP={psi->2,theta->-3.`};*)
(*procP=processNewParameters[newP,p];*)
(*(*capture messages*)*)
(*msg=Block[*)
(*{$MessagePrePrint=Sow,$MessageList={}},*)
(*Reap[Module[{},processNewParameters[newP,p];];$MessageList]*)
(*];*)
(*And@@{*)
(*(*values are numbers*)*)
(*And@@(NumberQ/@Values@procP),*)
(*(*parameters in processed list are same as in new parameters with added gamma*)*)
(*Sort@Keys@procP===Sort[Join[{gamma},Keys@newP]],*)
(*(*parameters in processed list are subset of old parameters*)*)
(*SubsetQ[Keys@p,Keys@procP],*)
(*(*not aborted*)*)
(*Not@checkAbrt[processNewParameters[newP,p]],*)
(*(*no message issued*)*)
(*ReleaseHold@msg=={{},{}},*)
(*(*gamma has correct value*)*)
(*Chop@RealAbs[(gamma/.procP)-(2.5)]<$MachineEpsilon*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*{gamma, psi}*)*)
(*p={delta->0.998`,Esx->0.0078`,gamma->10,muc->0.0015`,phisxs->2.3`*^-6,phix->0.044`,psi->1.5`,rhox->0.979`,theta->(1-gamma)/(1-1/psi),vx->0.987`,mud[1]->0.0015`,phidxd[1]->4.5`,rhodx[1]->3};*)
(*newP={psi->2,gamma->2.5};*)
(*procP=processNewParameters[newP,p];*)
(*(*capture messages*)*)
(*msg=Block[*)
(*{$MessagePrePrint=Sow,$MessageList={}},*)
(*Reap[Module[{},processNewParameters[newP,p];];$MessageList]*)
(*];*)
(*And@@{*)
(*(*values are numbers*)*)
(*And@@(NumberQ/@Values@procP),*)
(*(*parameters in processed list are same as in new parameters with added theta*)*)
(*Sort@Keys@procP===Sort[Join[{theta},Keys@newP]],*)
(*(*parameters in processed list are subset of old parameters*)*)
(*SubsetQ[Keys@p,Keys@procP],*)
(*(*not aborted*)*)
(*Not@checkAbrt[processNewParameters[newP,p]],*)
(*(*no message issued*)*)
(*ReleaseHold@msg=={{},{}},*)
(*(*theta has correct value*)*)
(*RealAbs[(theta/.procP)-(-3)]<$MachineEpsilon*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*{gamma, theta}*)*)
(*p={delta->0.998`,Esx->0.0078`,gamma->10,muc->0.0015`,phisxs->2.3`*^-6,phix->0.044`,psi->1.5`,rhox->0.979`,theta->(1-gamma)/(1-1/psi),vx->0.987`,mud[1]->0.0015`,phidxd[1]->4.5`,rhodx[1]->3};*)
(*newP={gamma->2.5,theta->-3.`};*)
(*procP=processNewParameters[newP,p];*)
(*(*capture messages*)*)
(*msg=Block[*)
(*{$MessagePrePrint=Sow,$MessageList={}},*)
(*Reap[Module[{},processNewParameters[newP,p];];$MessageList]*)
(*];*)
(*And@@{*)
(*(*values are numbers*)*)
(*And@@(NumberQ/@Values@procP),*)
(*(*parameters in processed list are same as in new parameters with added psi*)*)
(*Sort@Keys@procP===Sort[Join[{psi},Keys@newP]],*)
(*(*parameters in processed list are subset of old parameters*)*)
(*SubsetQ[Keys@p,Keys@procP],*)
(*(*not aborted*)*)
(*Not@checkAbrt[processNewParameters[newP,p]],*)
(*(*no message issued*)*)
(*ReleaseHold@msg=={{},{}},*)
(*(*psi has correct value*)*)
(*RealAbs[(psi/.procP)-(2)]<$MachineEpsilon*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*if theta provided without gamma or psi, abort*)*)
(*p={delta->0.998`,Esx->0.0078`,gamma->10,muc->0.0015`,phisxs->2.3`*^-6,phix->0.044`,psi->1.5`,rhox->0.979`,theta->(1-gamma)/(1-1/psi),vx->0.987`,mud[1]->0.0015`,phidxd[1]->4.5`,rhodx[1]->3};*)
(*newP={delta->0.9,Esx->1,theta->1.};*)
(*And@@{*)
(*(*aborts*)*)
(*checkAbrt[processNewParameters[newP,p]],*)
(*(*with message subsetparam*)*)
(*checkMsg[processNewParameters[newP,p],FernandoDuarte`LongRunRisk`Tools`ToNumber`processNewParameters::theta]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*processNewParameters preserves contexts of old parameters*)*)
(*p={context1`delta->0.998`,context1`Esx->0.0078`,foo`gamma->10,muc->0.0015`,phisxs->2.3`*^-6,phix->0.044`,psi->1.5`,rhox->0.979`,theta->(1-gamma)/(1-1/psi),vx->0.987`,mud[1]->0.0015`,phidxd[1]->4.5`,rhodx[1]->3};*)
(*newP={context2`delta->0.9, Esx->1, bar`gamma->2};*)
(*procP=processNewParameters[newP,p];*)
(*And@@{*)
(*(*contexts of newP do not match those in old parameters in p*)*)
(*KeyTake[p,Keys@newP]===<||>,*)
(*(*contexts of procP match those in old parameters in p*)*)
(*(Context/@Keys@procP)===Context/@(Keys@KeyTake[p,Keys@procP])*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*End[];*)


(* ::Input:: *)
(*addBeginEnd[testFilePath,testContext];*)
(*{*)
(*tr[Evaluate@name]["TestReport"] ,*)
(*tr[Evaluate@name]["ActualOutput"] ,*)
(*tr[Evaluate@name]["ExpectedOutput"] ,*)
(*tr[Evaluate@name]["OutputTrueQ"]*)
(*}=runTests[testFilePath];*)
(*(*tableActualVsExpeected[testName_String];*)*)
(*cleanUp[];*)


(* ::Section:: *)
(*PacletizeResources*)


(* ::Input:: *)
(*name = First@NotebookRead[PreviousCell[CellStyle -> "Section"]]*)
(*testFileName = name <>".wlt"*)
(*testFilePath = FileNameJoin[{testsDir,testFileName}]*)
(*If[FileNames[testFilePath]==={},Nothing,DeleteFile[testFilePath]]*)
(*testContext = "FernandoDuarte`LongRunRisk`Tests`"<>name<>"`"*)
(*context = "FernandoDuarte`LongRunRisk`"<>name*)


(* ::Input:: *)
(*Begin[Evaluate@testContext];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*Needs["FernandoDuarte`LongRunRisk`"];*)
(*True*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*ResourceFunction["WriteUnitTest"][testFilePath,*)
(*(*should all be True*)*)
(*And@@{*)
(*Not@SameQ[PacletFind["MaTeX"],{}],*)
(*Not@SameQ[PacletFind["PacletizedResourceFunctions"],{}],*)
(*MemberQ[$Packages,"MaTeX`"],*)
(*PacletFind["MaTeX"][[1]]["Version"]==="1.7.9",*)
(*Not@SameQ[PacletFind[Names["*NeedsDefinitions"]],{}],*)
(*Not@SameQ[PacletFind[Names["*SetSymbolsContext"]],{}]*)
(*}*)
(*,"ConfirmResults"->confirm];*)


(* ::Input:: *)
(*End[];*)


(* ::Input:: *)
(*addBeginEnd[testFilePath,testContext];*)
(*{*)
(*tr[Evaluate@name]["TestReport"] ,*)
(*tr[Evaluate@name]["ActualOutput"] ,*)
(*tr[Evaluate@name]["ExpectedOutput"] ,*)
(*tr[Evaluate@name]["OutputTrueQ"]*)
(*}=runTests[testFilePath];*)
(*(*tableActualVsExpeected[testName_String];*)*)
(*cleanUp[];*)


(* ::Chapter::Closed:: *)
(*Results*)


(* ::Input:: *)
(*keysTr=DeleteDuplicates@Cases[Keys@SubValues@tr,Verbatim[HoldPattern][tr[x_String][y_String]]:>x];*)
(*And@@Flatten@{*)
(*tr[#]["OutputTrueQ"]&/@keysTr,*)
(*tr[#]["TestReport"]["ReportSucceeded"]&/@keysTr*)
(*}*)


(* ::Section:: *)
(*Paclet Test*)


(* ::Input:: *)
(*SetOptions[$FrontEnd, "ClearEvaluationQueueOnKernelQuit" -> False]*)


(* ::Input:: *)
(*Exit[](*Quit[]*)*)


(* ::Input:: *)
(*pacletBaseDir=DirectoryName[NotebookDirectory[],2];*)
(*PacletUninstall["Wolfram/PacletCICD"];*)
(*PacletInstall["Wolfram/PacletCICD"->"0.35.0"];*)
(*Needs["Wolfram`PacletCICD`"];*)
(*testResults=TestPaclet[pacletBaseDir,"MarkdownSummary"->False]*)
(*And@@Values@((#["ReportSucceeded"])&/@testResults["Result"])*)


(* ::Section:: *)
(*Run All Tests Together*)


(* ::Input:: *)
(*(*Quit[]*)*)


(* ::Input:: *)
(*pacletBaseDir=DirectoryName[NotebookDirectory[],2];*)
(*PacletDirectoryLoad[pacletBaseDir];*)
(*testFileNames = FileNames[FileNameJoin[{pacletBaseDir,"Tests","*.wlt"}]];*)
(*$ContextPath=Cases[$ContextPath,Except["PacletizedResourceFunctions`"]];*)


(* ::Input:: *)
(*trAll=TestReport[testFileNames]*)
(*trAll["ReportSucceeded"]*)
(*trAll["TestsFailedWrongResults"]*)
(*trAll["TestsFailedWithMessages"]*)


(* ::Input:: *)
(*(**)
(*ex=(trAll["TestsFailedWrongResults"][[1]])["ExpectedOutput"];*)
(*ac=(trAll["TestsFailedWrongResults"][[1]])["ActualOutput"];*)
(**)
(*Table[ex[[1,i]]//Dataset,{i,1,Length[ex[[1]]]}]//TableForm*)
(*Table[ac[[1,i]]//Dataset,{i,1,Length[ex[[1]]]}]//TableForm*)
(**)
(*Table[ex[[1,i]]===ac[[1,i]],{i,1,Length[ex[[1]]]}]*)
(**)
(*ex=(tr["TestsFailedWithMessages"][[1]])["ExpectedMessages"]*)
(*ac=(tr["TestsFailedWithMessages"][[1]])["ActualMessages"]*)
(**)
(*Table[ex[[1,i]]//Dataset,{i,1,Length[ex[[1]]]}]//TableForm*)
(*Table[ac[[1,i]]//Dataset,{i,1,Length[ex[[1]]]}]//TableForm*)
(**)
(*Table[ex[[1,i]]===ac[[1,i]],{i,1,Length[ex[[1]]]}]*)
(**)*)


(* ::Section:: *)
(*Run Individual Tests Separately*)


(* ::Input:: *)
(*(*Quit[]*)*)


(* ::Input:: *)
(*pacletBaseDir=DirectoryName[NotebookDirectory[],2];*)
(*PacletDirectoryLoad[pacletBaseDir];*)
(*testFileNames = FileNames[FileNameJoin[{pacletBaseDir,"Tests","*.wlt"}]];*)
(*$ContextPath=Cases[$ContextPath,Except["PacletizedResourceFunctions`"]];*)


(* ::Input:: *)
(*trInd=TestReport["/Users/fernandoduarte/Dropbox (Personal)/MyPackages/LongRunRisk/Tests/Catalog.wlt"]*)
(*actual=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ActualOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*expected=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ExpectedOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*And@@Flatten@actual*)
(*And@@Flatten@expected*)


(* ::Input:: *)
(*trInd=TestReport["/Users/fernandoduarte/Dropbox (Personal)/MyPackages/LongRunRisk/Tests/Shocks.wlt"]*)
(*actual=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ActualOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*expected=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ExpectedOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*And@@Flatten@actual*)
(*And@@Flatten@expected*)


(* ::Input:: *)
(*trInd=TestReport["/Users/fernandoduarte/Dropbox (Personal)/MyPackages/LongRunRisk/Tests/ExogenousEq.wlt"]*)
(*actual=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ActualOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*expected=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ExpectedOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*And@@Flatten@actual*)
(*And@@Flatten@expected*)


(* ::Input:: *)
(*trInd=TestReport["/Users/fernandoduarte/Dropbox (Personal)/MyPackages/LongRunRisk/Tests/EndogenousEq.wlt"]*)
(*actual=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ActualOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*expected=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ExpectedOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*And@@Flatten@actual*)
(*And@@Flatten@expected*)


(* ::Input:: *)
(*trInd=TestReport["/Users/fernandoduarte/Dropbox (Personal)/MyPackages/LongRunRisk/Tests/ComputeConditionalExpectations.wlt"]*)
(*actual=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ActualOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*expected=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ExpectedOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*And@@Flatten@actual*)
(*And@@Flatten@expected*)


(* ::Input:: *)
(*trInd=TestReport["/Users/fernandoduarte/Dropbox (Personal)/MyPackages/LongRunRisk/Tests/ComputeUnconditionalExpectations.wlt"]*)
(*actual=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ActualOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*expected=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ExpectedOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*And@@Flatten@actual*)
(*And@@Flatten@expected*)


(* ::Input:: *)
(*trInd=TestReport["/Users/fernandoduarte/Dropbox (Personal)/MyPackages/LongRunRisk/Tests/CreateEulerEq.wlt"]*)
(*actual=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ActualOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*expected=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ExpectedOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*And@@Flatten@actual*)
(*And@@Flatten@expected*)


(* ::Input:: *)
(*trInd=TestReport["/Users/fernandoduarte/Dropbox (Personal)/MyPackages/LongRunRisk/Tests/SolveEulerEq.wlt"]*)
(*actual=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ActualOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*expected=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ExpectedOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*And@@Flatten@actual*)
(*And@@Flatten@expected*)


(* ::Input:: *)
(*trInd=TestReport["/Users/fernandoduarte/Dropbox (Personal)/MyPackages/LongRunRisk/Tests/TimeAggregation.wlt"]*)
(*actual=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ActualOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*expected=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ExpectedOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*And@@Flatten@actual*)
(*And@@Flatten@expected*)


(* ::Input:: *)
(*trInd=TestReport["/Users/fernandoduarte/Dropbox (Personal)/MyPackages/LongRunRisk/Tests/PacletizeResources.wlt"]*)
(*actual=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ActualOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*expected=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ExpectedOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*And@@Flatten@actual*)
(*And@@Flatten@expected*)


(* ::Input:: *)
(*trInd=TestReport["/Users/fernandoduarte/Dropbox (Personal)/MyPackages/LongRunRisk/Tests/NiceOutput.wlt"]*)
(*actual=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ActualOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*expected=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ExpectedOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*And@@Flatten@actual*)
(*And@@Flatten@expected*)


(* ::Input:: *)
(*trInd=TestReport["/Users/fernandoduarte/Dropbox (Personal)/MyPackages/LongRunRisk/Tests/ToNumber.wlt"]*)
(*actual=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ActualOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*expected=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ExpectedOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*And@@Flatten@actual*)
(*And@@Flatten@expected*)


(* ::Input:: *)
(*trInd=TestReport["/Users/fernandoduarte/Dropbox (Personal)/MyPackages/LongRunRisk/Tests/ProcessModels.wlt"]*)
(*actual=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ActualOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*expected=Table[Flatten@{(ReleaseHold@(trInd["Results"][[jj,1]][["ExpectedOutput"]]))},{jj,1,Length[trInd["Results"]]}];*)
(*And@@Flatten@actual*)
(*And@@Flatten@expected*)


(* ::Input:: *)
(*SetOptions[$FrontEnd, "ClearEvaluationQueueOnKernelQuit" -> True]*)
